"use strict";exports.id=954,exports.ids=[954],exports.modules={1578:e=>{var t=Object.defineProperty,s=Object.getOwnPropertyDescriptor,i=Object.getOwnPropertyNames,n=Object.prototype.hasOwnProperty,r={};((e,s)=>{for(var i in s)t(e,i,{get:s[i],enumerable:!0})})(r,{Analytics:()=>l}),e.exports=((e,r,c,o)=>{if(r&&"object"==typeof r||"function"==typeof r)for(let c of i(r))n.call(e,c)||void 0===c||t(e,c,{get:()=>r[c],enumerable:!(o=s(r,c))||o.enumerable});return e})(t({},"__esModule",{value:!0}),r);var c=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,o=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1]) -- First timestamp to check
local increment = tonumber(ARGV[2])       -- Increment between each timestamp
local num_timestamps = tonumber(ARGV[3])  -- Number of timestampts to check (24 for a day and 24 * 7 for a week)
local num_elements = tonumber(ARGV[4])    -- Number of elements to fetch in each category
local check_at_most = tonumber(ARGV[5])   -- Number of elements to check at most.

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local denied_group = {}
local true_count = 0
local false_count = 0
local denied_count = 0
local i = #result - 1

-- index to stop at after going through "checkAtMost" many items:
local cutoff_index = #result - 2 * check_at_most

-- iterate over the results
while (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i and i >= cutoff_index do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    elseif string.find(element, "success\\":\\"denied") and denied_count < num_elements then
      table.insert(denied_group, {score, element})
      denied_count = denied_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group, denied_group}
`,a=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`,l=class{redis;prefix;bucketSize;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window)}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if("number"==typeof e){if(e<=0)throw Error(`Invalid window: ${e}`);return e}let t=/^(\d+)([smhd])$/;if(!t.test(e))throw Error(`Invalid window: ${e}`);let[,s,i]=e.match(t),n=parseInt(s);switch(i){case"s":return 1e3*n;case"m":return 6e4*n;case"h":return 36e5*n;case"d":return 864e5*n;default:throw Error(`Invalid window unit: ${i}`)}}getBucket(e){return Math.floor((e??Date.now())/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async t=>{let s=this.getBucket(t.time),i=[this.prefix,e,s].join(":");await this.redis.zincrby(i,1,JSON.stringify({...t,time:void 0}))}))}formatBucketAggregate(e,t,s){let i={};return e.forEach(([e,s])=>{"success"==t&&(e=1===e?"true":null===e?"false":e),i[t]=i[t]||{},i[t][(e??"null").toString()]=s}),{time:s,...i}}async aggregateBucket(e,t,s){this.validateTableName(e);let i=this.getBucket(s),n=[this.prefix,e,i].join(":"),r=await this.redis.eval(c,[n],[t]);return this.formatBucketAggregate(r,t,i)}async aggregateBuckets(e,t,s,i){this.validateTableName(e);let n=this.getBucket(i),r=[];for(let i=0;i<s;i+=1)r.push(this.aggregateBucket(e,t,n)),n-=this.bucketSize;return Promise.all(r)}async aggregateBucketsWithPipeline(e,t,s,i,n){this.validateTableName(e),n=n??48;let r=this.getBucket(i),o=[],a=this.redis.pipeline(),l=[];for(let i=1;i<=s;i+=1){let h=[this.prefix,e,r].join(":");a.eval(c,[h],[t]),o.push(r),r-=this.bucketSize,(i%n==0||i==s)&&(l.push(a.exec()),a=this.redis.pipeline())}return(await Promise.all(l)).flat().map((e,s)=>this.formatBucketAggregate(e,t,o[s]))}async getAllowedBlocked(e,t,s){this.validateTableName(e);let i=[this.prefix,e].join(":"),n=this.getBucket(s),r=await this.redis.eval(a,[i],[n,this.bucketSize,t]),c={};for(let e=0;e<r.length;e+=2){let t=r[e],s=t.identifier,i=+r[e+1];c[s]||(c[s]={success:0,blocked:0}),c[s][t.success?"success":"blocked"]=i}return c}async getMostAllowedBlocked(e,t,s,i,n){this.validateTableName(e);let r=[this.prefix,e].join(":"),c=this.getBucket(i),[a,l,h]=await this.redis.eval(o,[r],[c,this.bucketSize,t,s,n??5*s]);return{allowed:this.toDicts(a),ratelimited:this.toDicts(l),denied:this.toDicts(h)}}toDicts(e){let t=[];for(let s=0;s<e.length;s+=1){let i=+e[s][0],n=e[s][1];t.push({identifier:n.identifier,count:i})}return t}}},6593:(e,t,s)=>{var i=Object.defineProperty,n=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,c=Object.prototype.hasOwnProperty,o=(e,t)=>{for(var s in t)i(e,s,{get:t[s],enumerable:!0})},a={};o(a,{Analytics:()=>h,IpDenyList:()=>k,MultiRegionRatelimit:()=>M,Ratelimit:()=>U}),e.exports=((e,t,s,o)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of r(t))c.call(e,s)||void 0===s||i(e,s,{get:()=>t[s],enumerable:!(o=n(t,s))||o.enumerable});return e})(i({},"__esModule",{value:!0}),a);var l=s(1578),h=class{analytics;table="events";constructor(e){this.analytics=new l.Analytics({redis:e.redis,window:"1h",prefix:e.prefix??"@upstash/ratelimit",retention:"90d"})}extractGeo(e){return void 0!==e.geo?e.geo:void 0!==e.cf?e.cf:{}}async record(e){await this.analytics.ingest(this.table,e)}async series(e,t){let s=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(t))/36e5,256);return this.analytics.aggregateBucketsWithPipeline(this.table,e,s)}async getUsage(e=0){let t=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(e))/36e5,256);return await this.analytics.getAllowedBlocked(this.table,t)}async getUsageOverTime(e,t){return await this.analytics.aggregateBucketsWithPipeline(this.table,t,e)}async getMostAllowedBlocked(e,t,s){return t=t??5,this.analytics.getMostAllowedBlocked(this.table,e,t,void 0,s)}},p=class{cache;constructor(e){this.cache=e}isBlocked(e){if(!this.cache.has(e))return{blocked:!1,reset:0};let t=this.cache.get(e);return t<Date.now()?(this.cache.delete(e),{blocked:!1,reset:0}):{blocked:!0,reset:t}}blockUntil(e,t){this.cache.set(e,t)}set(e,t){this.cache.set(e,t)}get(e){return this.cache.get(e)||null}incr(e,t=1){let s=this.cache.get(e)??0;return s+=t,this.cache.set(e,s),s}pop(e){this.cache.delete(e)}empty(){this.cache.clear()}size(){return this.cache.size}},u=":dynamic:global",d="@upstash/ratelimit";function m(e){let t=e.match(/^(\d+)\s?(ms|s|m|h|d)$/);if(!t)throw Error(`Unable to parse window size: ${e}`);let s=Number.parseInt(t[1]);switch(t[2]){case"ms":return s;case"s":return 1e3*s;case"m":return 6e4*s;case"h":return 36e5*s;case"d":return 864e5*s;default:throw Error(`Unable to parse window size: ${e}`)}}var w=async(e,t,s,i)=>{try{return await e.redis.evalsha(t.hash,s,i)}catch(n){if(`${n}`.includes("NOSCRIPT"))return await e.redis.eval(t.script,s,i);throw n}},x={singleRegion:{fixedWindow:{limit:{script:`
  local key           = KEYS[1]
  local dynamicLimitKey = KEYS[2]  -- optional: key for dynamic limit in redis
  local tokens        = tonumber(ARGV[1])  -- default limit
  local window        = ARGV[2]
  local incrementBy   = ARGV[3] -- increment rate per request at a given value, default is 1

  -- Check for dynamic limit
  local effectiveLimit = tokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end

  local r = redis.call("INCRBY", key, incrementBy)
  if r == tonumber(incrementBy) then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end

  return {r, effectiveLimit}
`,hash:"472e55443b62f60d0991028456c57815a387066d"},getRemaining:{script:`
  local key = KEYS[1]
  local dynamicLimitKey = KEYS[2]  -- optional: key for dynamic limit in redis
  local tokens = tonumber(ARGV[1])  -- default limit

  -- Check for dynamic limit
  local effectiveLimit = tokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end

  local value = redis.call('GET', key)
  local usedTokens = 0
  if value then
    usedTokens = tonumber(value)
  end
  
  return {effectiveLimit - usedTokens, effectiveLimit}
`,hash:"40515c9dd0a08f8584f5f9b593935f6a87c1c1c3"}},slidingWindow:{limit:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local dynamicLimitKey = KEYS[3]       -- optional: key for dynamic limit in redis
  local tokens      = tonumber(ARGV[1]) -- default tokens per window
  local now         = ARGV[2]           -- current timestamp in milliseconds
  local window      = ARGV[3]           -- interval in milliseconds
  local incrementBy = tonumber(ARGV[4]) -- increment rate per request at a given value, default is 1

  -- Check for dynamic limit
  local effectiveLimit = tokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end
  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  -- Only check limit if not refunding (negative rate)
  if incrementBy > 0 and requestsInPreviousWindow + requestsInCurrentWindow >= effectiveLimit then
    return {-1, effectiveLimit}
  end

  local newValue = redis.call("INCRBY", currentKey, incrementBy)
  if newValue == incrementBy then
    -- The first time this key is set, the value will be equal to incrementBy.
    -- So we only need the expire command once
    redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
  end
  return {effectiveLimit - ( newValue + requestsInPreviousWindow ), effectiveLimit}
`,hash:"977fb636fb5ceb7e98a96d1b3a1272ba018efdae"},getRemaining:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local dynamicLimitKey = KEYS[3]       -- optional: key for dynamic limit in redis
  local tokens      = tonumber(ARGV[1]) -- default tokens per window
  local now         = ARGV[2]           -- current timestamp in milliseconds
  local window      = ARGV[3]           -- interval in milliseconds

  -- Check for dynamic limit
  local effectiveLimit = tokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end

  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  local usedTokens = requestsInPreviousWindow + requestsInCurrentWindow
  return {effectiveLimit - usedTokens, effectiveLimit}
`,hash:"ee3a3265fad822f83acad23f8a1e2f5c0b156b03"}},tokenBucket:{limit:{script:`
  local key         = KEYS[1]           -- identifier including prefixes
  local dynamicLimitKey = KEYS[2]       -- optional: key for dynamic limit in redis
  local maxTokens   = tonumber(ARGV[1]) -- default maximum number of tokens
  local interval    = tonumber(ARGV[2]) -- size of the window in milliseconds
  local refillRate  = tonumber(ARGV[3]) -- how many tokens are refilled after each interval
  local now         = tonumber(ARGV[4]) -- current timestamp in milliseconds
  local incrementBy = tonumber(ARGV[5]) -- how many tokens to consume, default is 1

  -- Check for dynamic limit
  local effectiveLimit = maxTokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")
        
  local refilledAt
  local tokens

  if bucket[1] == false then
    refilledAt = now
    tokens = effectiveLimit
  else
    refilledAt = tonumber(bucket[1])
    tokens = tonumber(bucket[2])
  end
        
  if now >= refilledAt + interval then
    local numRefills = math.floor((now - refilledAt) / interval)
    tokens = math.min(effectiveLimit, tokens + numRefills * refillRate)

    refilledAt = refilledAt + numRefills * interval
  end

  -- Only reject if tokens are 0 and we're consuming (not refunding)
  if tokens == 0 and incrementBy > 0 then
    return {-1, refilledAt + interval, effectiveLimit}
  end

  local remaining = tokens - incrementBy
  local expireAt = math.ceil(((effectiveLimit - remaining) / refillRate)) * interval
        
  redis.call("HSET", key, "refilledAt", refilledAt, "tokens", remaining)

  if (expireAt > 0) then
    redis.call("PEXPIRE", key, expireAt)
  end
  return {remaining, refilledAt + interval, effectiveLimit}
`,hash:"b35c5bc0b7fdae7dd0573d4529911cabaf9d1d89"},getRemaining:{script:`
  local key         = KEYS[1]
  local dynamicLimitKey = KEYS[2]       -- optional: key for dynamic limit in redis
  local maxTokens   = tonumber(ARGV[1]) -- default maximum number of tokens

  -- Check for dynamic limit
  local effectiveLimit = maxTokens
  if dynamicLimitKey ~= "" then
    local dynamicLimit = redis.call("GET", dynamicLimitKey)
    if dynamicLimit then
      effectiveLimit = tonumber(dynamicLimit)
    end
  end
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")

  if bucket[1] == false then
    return {effectiveLimit, -1, effectiveLimit}
  end
        
  return {tonumber(bucket[2]), tonumber(bucket[1]), effectiveLimit}
`,hash:"deb03663e8af5a968deee895dd081be553d2611b"}},cachedFixedWindow:{limit:{script:`
  local key     = KEYS[1]
  local window  = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == incrementBy then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end
      
  return r
`,hash:"c26b12703dd137939b9a69a3a9b18e906a2d940f"},getRemaining:{script:`
  local key = KEYS[1]
  local tokens = 0

  local value = redis.call('GET', key)
  if value then
      tokens = value
  end
  return tokens
`,hash:"8e8f222ccae68b595ee6e3f3bf2199629a62b91a"}}},multiRegion:{fixedWindow:{limit:{script:`
	local key           = KEYS[1]
	local id            = ARGV[1]
	local window        = ARGV[2]
	local incrementBy   = tonumber(ARGV[3])

	redis.call("HSET", key, id, incrementBy)
	local fields = redis.call("HGETALL", key)
	if #fields == 2 and tonumber(fields[2])==incrementBy then
	-- The first time this key is set, and the value will be equal to incrementBy.
	-- So we only need the expire command once
	  redis.call("PEXPIRE", key, window)
	end

	return fields
`,hash:"a8c14f3835aa87bd70e5e2116081b81664abcf5c"},getRemaining:{script:`
      local key = KEYS[1]
      local tokens = 0

      local fields = redis.call("HGETALL", key)

      return fields
    `,hash:"8ab8322d0ed5fe5ac8eb08f0c2e4557f1b4816fd"}},slidingWindow:{limit:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local tokens        = tonumber(ARGV[1]) -- tokens per window
	local now           = ARGV[2]           -- current timestamp in milliseconds
	local window        = ARGV[3]           -- interval in milliseconds
	local requestId     = ARGV[4]           -- uuid for this request
	local incrementBy   = tonumber(ARGV[5]) -- custom rate, default is  1

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window

	-- Only check limit if not refunding (negative rate)
	if incrementBy > 0 and requestsInPreviousWindow * (1 - percentageInCurrent ) + requestsInCurrentWindow + incrementBy > tokens then
	  return {currentFields, previousFields, false}
	end

	redis.call("HSET", currentKey, requestId, incrementBy)

	if requestsInCurrentWindow == 0 then 
	  -- The first time this key is set, the value will be equal to incrementBy.
	  -- So we only need the expire command once
	  redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
	end
	return {currentFields, previousFields, true}
`,hash:"1e7ca8dcd2d600a6d0124a67a57ea225ed62921b"},getRemaining:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local now         	= ARGV[1]           -- current timestamp in milliseconds
  	local window      	= ARGV[2]           -- interval in milliseconds

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window
  	requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)
	
	return requestsInCurrentWindow + requestsInPreviousWindow
`,hash:"558c9306b7ec54abb50747fe0b17e5d44bd24868"}}}},f={script:`
      local pattern = KEYS[1]

      -- Initialize cursor to start from 0
      local cursor = "0"

      repeat
          -- Scan for keys matching the pattern
          local scan_result = redis.call('SCAN', cursor, 'MATCH', pattern)

          -- Extract cursor for the next iteration
          cursor = scan_result[1]

          -- Extract keys from the scan result
          local keys = scan_result[2]

          for i=1, #keys do
          redis.call('DEL', keys[i])
          end

      -- Continue scanning until cursor is 0 (end of keyspace)
      until cursor == "0"
    `,hash:"54bd274ddc59fb3be0f42deee2f64322a10e2b50"},y="denyList",g="ipDenyList",b="ipDenyListStatus",O=`
  -- Checks if values provideed in ARGV are present in the deny lists.
  -- This is done using the allDenyListsKey below.

  -- Additionally, checks the status of the ip deny list using the
  -- ipDenyListStatusKey below. Here are the possible states of the
  -- ipDenyListStatusKey key:
  -- * status == -1: set to "disabled" with no TTL
  -- * status == -2: not set, meaning that is was set before but expired
  -- * status  >  0: set to "valid", with a TTL
  --
  -- In the case of status == -2, we set the status to "pending" with
  -- 30 second ttl. During this time, the process which got status == -2
  -- will update the ip deny list.

  local allDenyListsKey     = KEYS[1]
  local ipDenyListStatusKey = KEYS[2]

  local results = redis.call('SMISMEMBER', allDenyListsKey, unpack(ARGV))
  local status  = redis.call('TTL', ipDenyListStatusKey)
  if status == -2 then
    redis.call('SETEX', ipDenyListStatusKey, 30, "pending")
  end

  return { results, status }
`,k={};o(k,{ThresholdError:()=>v,disableIpDenyList:()=>R,updateIpDenyList:()=>A});var E=e=>864e5-((e||Date.now())-72e5)%864e5,v=class extends Error{constructor(e){super(`Allowed threshold values are from 1 to 8, 1 and 8 included. Received: ${e}`),this.name="ThresholdError"}},S=async e=>{if("number"!=typeof e||e<1||e>8)throw new v(e);try{let t=await fetch(`https://raw.githubusercontent.com/stamparm/ipsum/master/levels/${e}.txt`);if(!t.ok)throw Error(`Error fetching data: ${t.statusText}`);return(await t.text()).split("\n").filter(e=>e.length>0)}catch(e){throw Error(`Failed to fetch ip deny list: ${e}`)}},A=async(e,t,s,i)=>{let n=await S(s),r=[t,y,"all"].join(":"),c=[t,y,g].join(":"),o=[t,b].join(":"),a=e.multi();return a.sdiffstore(r,r,c),a.del(c),a.sadd(c,n.at(0),...n.slice(1)),a.sdiffstore(c,c,r),a.sunionstore(r,r,c),a.set(o,"valid",{px:i??E()}),await a.exec()},R=async(e,t)=>{let s=[t,y,"all"].join(":"),i=[t,y,g].join(":"),n=[t,b].join(":"),r=e.multi();return r.sdiffstore(s,s,i),r.del(i),r.set(n,"disabled"),await r.exec()},T=new p(new Map),L=e=>e.find(e=>T.isBlocked(e).blocked),I=e=>{T.size()>1e3&&T.empty(),T.blockUntil(e,Date.now()+6e4)},P=async(e,t,s)=>{let i;let[n,r]=await e.eval(O,[[t,y,"all"].join(":"),[t,b].join(":")],s);return n.map((e,t)=>{e&&(I(s[t]),i=s[t])}),{deniedValue:i,invalidIpDenyList:-2===r}},N=(e,t,[s,i],n)=>{if(i.deniedValue&&(s.success=!1,s.remaining=0,s.reason="denyList",s.deniedValue=i.deniedValue),i.invalidIpDenyList){let i=A(e,t,n);s.pending=Promise.all([s.pending,i])}return s},C=e=>({success:!1,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"denyList",deniedValue:e}),z=class{limiter;ctx;prefix;timeout;primaryRedis;analytics;enableProtection;denyListThreshold;dynamicLimits;constructor(e){this.ctx=e.ctx,this.limiter=e.limiter,this.timeout=e.timeout??5e3,this.prefix=e.prefix??d,this.dynamicLimits=e.dynamicLimits??!1,this.enableProtection=e.enableProtection??!1,this.denyListThreshold=e.denyListThreshold??6,this.primaryRedis="redis"in this.ctx?this.ctx.redis:this.ctx.regionContexts[0].redis,"redis"in this.ctx&&(this.ctx.dynamicLimits=this.dynamicLimits,this.ctx.prefix=this.prefix),this.analytics=e.analytics?new h({redis:this.primaryRedis,prefix:this.prefix}):void 0,e.ephemeralCache instanceof Map?this.ctx.cache=new p(e.ephemeralCache):void 0===e.ephemeralCache&&(this.ctx.cache=new p(new Map))}limit=async(e,t)=>{let s=null;try{let i=this.getRatelimitResponse(e,t),{responseArray:n,newTimeoutId:r}=this.applyTimeout(i);s=r;let c=await Promise.race(n);return this.submitAnalytics(c,e,t)}finally{s&&clearTimeout(s)}};blockUntilReady=async(e,t)=>{let s;if(t<=0)throw Error("timeout must be positive");let i=Date.now()+t;for(;!(s=await this.limit(e)).success;){if(0===s.reset)throw Error("This should not happen");let e=Math.min(s.reset,i)-Date.now();if(await new Promise(t=>setTimeout(t,e)),Date.now()>i)break}return s};resetUsedTokens=async e=>{let t=[this.prefix,e].join(":");await this.limiter().resetTokens(this.ctx,t)};getRemaining=async e=>{let t=[this.prefix,e].join(":");return await this.limiter().getRemaining(this.ctx,t)};getRatelimitResponse=async(e,t)=>{let s=this.getKey(e),i=this.getDefinedMembers(e,t),n=L(i),r=n?[C(n),{deniedValue:n,invalidIpDenyList:!1}]:await Promise.all([this.limiter().limit(this.ctx,s,t?.rate),this.enableProtection?P(this.primaryRedis,this.prefix,i):{deniedValue:void 0,invalidIpDenyList:!1}]);return N(this.primaryRedis,this.prefix,r,this.denyListThreshold)};applyTimeout=e=>{let t=null,s=[e];if(this.timeout>0){let e=new Promise(e=>{t=setTimeout(()=>{e({success:!0,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"timeout"})},this.timeout)});s.push(e)}return{responseArray:s,newTimeoutId:t}};submitAnalytics=(e,t,s)=>{if(this.analytics)try{let i=s?this.analytics.extractGeo(s):void 0,n=this.analytics.record({identifier:"denyList"===e.reason?e.deniedValue:t,time:Date.now(),success:"denyList"===e.reason?"denied":e.success,...i}).catch(e=>{let t="Failed to record analytics";`${e}`.includes("WRONGTYPE")&&(t=`
    Failed to record analytics. See the information below:

    This can occur when you uprade to Ratelimit version 1.1.2
    or later from an earlier version.

    This occurs simply because the way we store analytics data
    has changed. To avoid getting this error, disable analytics
    for *an hour*, then simply enable it back.

    `),console.warn(t,e)});e.pending=Promise.all([e.pending,n])}catch(e){console.warn("Failed to record analytics",e)}return e};getKey=e=>[this.prefix,e].join(":");getDefinedMembers=(e,t)=>[e,t?.ip,t?.userAgent,t?.country].filter(Boolean);setDynamicLimit=async e=>{if(!this.dynamicLimits)throw Error("dynamicLimits must be enabled in the Ratelimit constructor to use setDynamicLimit()");let t=`${this.prefix}${u}`;await (!1===e.limit?this.primaryRedis.del(t):this.primaryRedis.set(t,e.limit))};getDynamicLimit=async()=>{if(!this.dynamicLimits)throw Error("dynamicLimits must be enabled in the Ratelimit constructor to use getDynamicLimit()");let e=`${this.prefix}${u}`,t=await this.primaryRedis.get(e);return{dynamicLimit:null===t?null:Number(t)}}};function D(){let e="",t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",s=t.length;for(let i=0;i<16;i++)e+=t.charAt(Math.floor(Math.random()*s));return e}var M=class extends z{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,dynamicLimits:e.dynamicLimits,ctx:{regionContexts:e.redis.map(t=>({redis:t,prefix:e.prefix??d})),cache:e.ephemeralCache?new p(e.ephemeralCache):void 0}}),e.dynamicLimits&&console.warn("Warning: Dynamic limits are not yet supported for multi-region rate limiters. The dynamicLimits option will be ignored.")}static fixedWindow(e,t){let s=m(t);return()=>({async limit(t,i,n){let r=D(),c=Math.floor(Date.now()/s),o=[i,c].join(":"),a=n??1;if(t.cache&&a>0){let{blocked:s,reset:n}=t.cache.isBlocked(i);if(s)return{success:!1,limit:e,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let l=t.regionContexts.map(e=>({redis:e.redis,request:w(e,x.multiRegion.fixedWindow.limit,[o],[r,s,a])})),h=e-(await Promise.any(l.map(e=>e.request))).reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0);async function p(){let t=[...new Set((await Promise.all(l.map(e=>e.request))).flat().reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of l){let i=(await s.request).reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0),n=(await s.request).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(i>=e)continue;let r=t.filter(e=>!n.includes(e));if(0!==r.length)for(let e of r)await s.redis.hset(o,{[e]:a})}}let u=h>=0,d=(c+1)*s;return t.cache&&(u?a<0&&t.cache.pop(i):t.cache.blockUntil(i,d)),{success:u,limit:e,remaining:h,reset:d,pending:p()}},async getRemaining(t,i){let n=Math.floor(Date.now()/s),r=[i,n].join(":"),c=t.regionContexts.map(e=>({redis:e.redis,request:w(e,x.multiRegion.fixedWindow.getRemaining,[r],[null])}));return{remaining:Math.max(0,e-(await Promise.any(c.map(e=>e.request))).reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0)),reset:(n+1)*s,limit:e}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{w(e,f,[s],[null])}))}})}static slidingWindow(e,t){let s=m(t),i=m(t);return()=>({async limit(t,n,r){let c=D(),o=Date.now(),a=Math.floor(o/s),l=[n,a].join(":"),h=[n,a-1].join(":"),p=r??1;if(t.cache&&p>0){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let u=t.regionContexts.map(t=>({redis:t.redis,request:w(t,x.multiRegion.slidingWindow.limit,[l,h],[e,o,i,c,p])})),d=o%i/i,[m,f,y]=await Promise.any(u.map(e=>e.request));y&&m.push(c,p.toString());let g=f.reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0),b=e-(Math.ceil(g*(1-d))+m.reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0));async function O(){let t=[...new Set((await Promise.all(u.map(e=>e.request))).flatMap(([e])=>e).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of u){let[i,n,r]=await s.request,c=i.reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(i.reduce((e,t,s)=>{let i=0;return s%2&&(i=Number.parseInt(t)),e+i},0)>=e)continue;let o=t.filter(e=>!c.includes(e));if(0!==o.length)for(let e of o)await s.redis.hset(l,{[e]:p})}}let k=(a+1)*i;return t.cache&&(y?p<0&&t.cache.pop(n):t.cache.blockUntil(n,k)),{success:!!y,limit:e,remaining:Math.max(0,b),reset:k,pending:O()}},async getRemaining(t,i){let n=Date.now(),r=Math.floor(n/s),c=[i,r].join(":"),o=[i,r-1].join(":"),a=t.regionContexts.map(e=>({redis:e.redis,request:w(e,x.multiRegion.slidingWindow.getRemaining,[c,o],[n,s])}));return{remaining:Math.max(0,e-await Promise.any(a.map(e=>e.request))),reset:(r+1)*s,limit:e}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{w(e,f,[s],[null])}))}})}},U=class extends z{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,ctx:{redis:e.redis,prefix:e.prefix??d},ephemeralCache:e.ephemeralCache,enableProtection:e.enableProtection,denyListThreshold:e.denyListThreshold,dynamicLimits:e.dynamicLimits})}static fixedWindow(e,t){let s=m(t);return()=>({async limit(t,i,n){let r=Math.floor(Date.now()/s),c=[i,r].join(":"),o=n??1;if(t.cache&&o>0){let{blocked:s,reset:n}=t.cache.isBlocked(i);if(s)return{success:!1,limit:e,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let a=t.dynamicLimits?`${t.prefix}${u}`:"",[l,h]=await w(t,x.singleRegion.fixedWindow.limit,[c,a],[e,s,o]),p=l<=h,d=Math.max(0,h-l),m=(r+1)*s;return t.cache&&(p?o<0&&t.cache.pop(i):t.cache.blockUntil(i,m)),{success:p,limit:h,remaining:d,reset:m,pending:Promise.resolve()}},async getRemaining(t,i){let n=Math.floor(Date.now()/s),r=[i,n].join(":"),c=t.dynamicLimits?`${t.prefix}${u}`:"",[o,a]=await w(t,x.singleRegion.fixedWindow.getRemaining,[r,c],[e]);return{remaining:Math.max(0,o),reset:(n+1)*s,limit:a}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await w(e,f,[s],[null])}})}static slidingWindow(e,t){let s=m(t);return()=>({async limit(t,i,n){let r=Date.now(),c=Math.floor(r/s),o=[i,c].join(":"),a=[i,c-1].join(":"),l=n??1;if(t.cache&&l>0){let{blocked:s,reset:n}=t.cache.isBlocked(i);if(s)return{success:!1,limit:e,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let h=t.dynamicLimits?`${t.prefix}${u}`:"",[p,d]=await w(t,x.singleRegion.slidingWindow.limit,[o,a,h],[e,r,s,l]),m=p>=0,f=(c+1)*s;return t.cache&&(m?l<0&&t.cache.pop(i):t.cache.blockUntil(i,f)),{success:m,limit:d,remaining:Math.max(0,p),reset:f,pending:Promise.resolve()}},async getRemaining(t,i){let n=Date.now(),r=Math.floor(n/s),c=[i,r].join(":"),o=[i,r-1].join(":"),a=t.dynamicLimits?`${t.prefix}${u}`:"",[l,h]=await w(t,x.singleRegion.slidingWindow.getRemaining,[c,o,a],[e,n,s]);return{remaining:Math.max(0,l),reset:(r+1)*s,limit:h}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await w(e,f,[s],[null])}})}static tokenBucket(e,t,s){let i=m(t);return()=>({async limit(t,n,r){let c=Date.now(),o=r??1;if(t.cache&&o>0){let{blocked:e,reset:i}=t.cache.isBlocked(n);if(e)return{success:!1,limit:s,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let a=t.dynamicLimits?`${t.prefix}${u}`:"",[l,h,p]=await w(t,x.singleRegion.tokenBucket.limit,[n,a],[s,i,e,c,o]),d=l>=0;return t.cache&&(d?o<0&&t.cache.pop(n):t.cache.blockUntil(n,h)),{success:d,limit:p,remaining:Math.max(0,l),reset:h,pending:Promise.resolve()}},async getRemaining(e,t){let n=e.dynamicLimits?`${e.prefix}${u}`:"",[r,c,o]=await w(e,x.singleRegion.tokenBucket.getRemaining,[t,n],[s]),a=Date.now()+i,l=c+i;return{remaining:Math.max(0,r),reset:-1===c?a:l,limit:o}},async resetTokens(e,t){e.cache&&e.cache.pop(t),await w(e,f,[t],[null])}})}static cachedFixedWindow(e,t){let s=m(t);return()=>({async limit(t,i,n){if(!t.cache)throw Error("This algorithm requires a cache");t.dynamicLimits&&console.warn("Warning: Dynamic limits are not yet supported for cachedFixedWindow algorithm. The dynamicLimits option will be ignored.");let r=Math.floor(Date.now()/s),c=[i,r].join(":"),o=(r+1)*s,a=n??1;if("number"==typeof t.cache.get(c)){let i=t.cache.incr(c,a),n=i<e,r=n?w(t,x.singleRegion.cachedFixedWindow.limit,[c],[s,a]):Promise.resolve();return{success:n,limit:e,remaining:e-i,reset:o,pending:r}}let l=await w(t,x.singleRegion.cachedFixedWindow.limit,[c],[s,a]);t.cache.set(c,l);let h=e-l;return{success:h>=0,limit:e,remaining:h,reset:o,pending:Promise.resolve()}},async getRemaining(t,i){if(!t.cache)throw Error("This algorithm requires a cache");let n=Math.floor(Date.now()/s),r=[i,n].join(":");return"number"==typeof t.cache.get(r)?{remaining:Math.max(0,e-(t.cache.get(r)??0)),reset:(n+1)*s,limit:e}:{remaining:Math.max(0,e-await w(t,x.singleRegion.cachedFixedWindow.getRemaining,[r],[null])),reset:(n+1)*s,limit:e}},async resetTokens(e,t){if(!e.cache)throw Error("This algorithm requires a cache");let i=[t,Math.floor(Date.now()/s)].join(":");e.cache.pop(i);let n=[t,"*"].join(":");await w(e,f,[n],[null])}})}}},2674:(e,t,s)=>{s.d(t,{Q:()=>sF});var i=s(7598);let n=i.webcrypto?.subtle||{};var r=Object.defineProperty;((e,t)=>{for(var s in t)r(e,s,{get:t[s],enumerable:!0})})({},{UpstashError:()=>c,UpstashJSONParseError:()=>a,UrlError:()=>o});var c=class extends Error{constructor(e,t){super(e,t),this.name="UpstashError"}},o=class extends Error{constructor(e){super(`Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${e}". `),this.name="UrlError"}},a=class extends c{constructor(e,t){super(`Unable to parse response body: ${e.length>200?e.slice(0,200)+"...":e}`,t),this.name="UpstashJSONParseError"}};function l(e){try{return function e(t){let s=Array.isArray(t)?t.map(t=>{try{return e(t)}catch{return t}}):JSON.parse(t);return"number"==typeof s&&s.toString()!==t?t:s}(e)}catch{return e}}function h(e){return[e[0],...l(e.slice(1))]}function p(e){let[t,s]=e,i=[];for(let e=0;e<s.length;e+=2)i.push({key:s[e],type:s[e+1]});return[t,i]}function u(e){if("object"==typeof e&&null!==e&&!Array.isArray(e))return e;if(!Array.isArray(e))return{};let t={};for(let s=0;s<e.length;s+=2)"string"==typeof e[s]&&(t[e[s]]=e[s+1]);return t}var d=class{baseUrl;headers;options;readYourWrites;upstashSyncToken="";hasCredentials;retry;constructor(e){if(this.options={backend:e.options?.backend,agent:e.agent,responseEncoding:e.responseEncoding??"base64",cache:e.cache,signal:e.signal,keepAlive:e.keepAlive??!0},this.upstashSyncToken="",this.readYourWrites=e.readYourWrites??!0,this.baseUrl=(e.baseUrl||"").replace(/\/$/,""),this.baseUrl&&!/^https?:\/\/[^\s#$./?].\S*$/.test(this.baseUrl))throw new o(this.baseUrl);this.headers={"Content-Type":"application/json",...e.headers},this.hasCredentials=!!(this.baseUrl&&this.headers.authorization.split(" ")[1]),"base64"===this.options.responseEncoding&&(this.headers["Upstash-Encoding"]="base64"),this.retry="boolean"!=typeof e.retry||e.retry?{attempts:e.retry?.retries??5,backoff:e.retry?.backoff??(e=>50*Math.exp(e))}:{attempts:1,backoff:()=>0}}mergeTelemetry(e){this.headers=x(this.headers,"Upstash-Telemetry-Runtime",e.runtime),this.headers=x(this.headers,"Upstash-Telemetry-Platform",e.platform),this.headers=x(this.headers,"Upstash-Telemetry-Sdk",e.sdk)}async request(e){let t;let s=function(...e){let t={};for(let s of e)if(s)for(let[e,i]of Object.entries(s))null!=i&&(t[e]=i);return t}(this.headers,e.headers??{}),i=[this.baseUrl,...e.path??[]].join("/"),n="text/event-stream"===s.Accept,r=e.signal??this.options.signal,o="function"==typeof r,l={cache:this.options.cache,method:"POST",headers:s,body:JSON.stringify(e.body),keepalive:this.options.keepAlive,agent:this.options.agent,signal:o?r():r,backend:this.options.backend};if(this.hasCredentials||console.warn("[Upstash Redis] Redis client was initialized without url or token. Failed to execute command."),this.readYourWrites){let e=this.upstashSyncToken;this.headers["upstash-sync-token"]=e}let h=null,p=null;for(let e=0;e<=this.retry.attempts;e++)try{h=await fetch(i,l);break}catch(t){if(l.signal?.aborted&&o)throw t;if(l.signal?.aborted){h=new Response(new Blob([JSON.stringify({result:l.signal.reason??"Aborted"})]),{status:200,statusText:l.signal.reason??"Aborted"});break}p=t,e<this.retry.attempts&&await new Promise(t=>setTimeout(t,this.retry.backoff(e)))}if(!h)throw p??Error("Exhausted all retries");if(!h.ok){let t;let s=await h.text();try{t=JSON.parse(s)}catch(e){throw new a(s,{cause:e})}throw new c(`${t.error}, command was: ${JSON.stringify(e.body)}`)}if(this.readYourWrites){let e=h.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}if(n&&e&&e.onMessage&&h.body){let t=h.body.getReader(),s=new TextDecoder;return(async()=>{try{let i="";for(;;){let{value:n,done:r}=await t.read();if(r)break;let c=(i+=s.decode(n,{stream:!0})).split("\n");if((i=c.pop()||"").length>1048576)throw Error("Buffer size exceeded (1MB)");for(let t of c)if(t.startsWith("data: ")){let s=t.slice(6);e.onMessage?.(s)}}}catch(e){e instanceof Error&&"AbortError"===e.name||console.error("Stream reading error:",e)}finally{try{await t.cancel()}catch{}}})(),{result:1}}let u=await h.text();try{t=JSON.parse(u)}catch(e){throw new a(u,{cause:e})}if(this.readYourWrites){let e=h.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}return"base64"===this.options.responseEncoding?Array.isArray(t)?t.map(({result:e,error:t})=>({result:w(e),error:t})):{result:w(t.result),error:t.error}:t}};function m(e){let t="";try{let s=atob(e),i=s.length,n=new Uint8Array(i);for(let e=0;e<i;e++)n[e]=s.charCodeAt(e);t=new TextDecoder().decode(n)}catch{t=e}return t}function w(e){let t;switch(typeof e){case"undefined":return e;case"number":t=e;break;case"object":t=Array.isArray(e)?e.map(e=>"string"==typeof e?m(e):Array.isArray(e)?e.map(e=>w(e)):e):null;break;case"string":t="OK"===e?"OK":m(e)}return t}function x(e,t,s){return s&&(e[t]=e[t]?[e[t],s].join(","):s),e}var f=e=>{switch(typeof e){case"string":case"number":case"boolean":return e;default:return JSON.stringify(e)}},y=class{command;serialize;deserialize;headers;path;onMessage;isStreaming;signal;constructor(e,t){if(this.serialize=f,this.deserialize=t?.automaticDeserialization===void 0||t.automaticDeserialization?t?.deserialize??l:e=>e,this.command=e.map(e=>this.serialize(e)),this.headers=t?.headers,this.path=t?.path,this.onMessage=t?.streamOptions?.onMessage,this.isStreaming=t?.streamOptions?.isStreaming??!1,this.signal=t?.streamOptions?.signal,t?.latencyLogging){let e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),i=await e(t),n=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${n} ms\x1b[0m`),i}}}async exec(e){let{result:t,error:s}=await e.request({body:this.command,path:this.path,upstashSyncToken:e.upstashSyncToken,headers:this.headers,onMessage:this.onMessage,isStreaming:this.isStreaming,signal:this.signal});if(s)throw new c(s);if(void 0===t)throw TypeError("Request did not return a result");return this.deserialize(t)}},g=class extends y{constructor(e,t){let s=["hrandfield",e[0]];"number"==typeof e[1]&&s.push(e[1]),e[2]&&s.push("WITHVALUES"),super(s,{deserialize:e[2]?e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let i=e[s],n=e[s+1];try{t[i]=JSON.parse(n)}catch{t[i]=n}}return t})(e):t?.deserialize,...t})}},b=class extends y{constructor(e,t){super(["append",...e],t)}},O=class extends y{constructor([e,t,s],i){let n=["bitcount",e];"number"==typeof t&&n.push(t),"number"==typeof s&&n.push(s),super(n,i)}},k=class{constructor(e,t,s,i=e=>e.exec(this.client)){this.client=t,this.opts=s,this.execOperation=i,this.command=["bitfield",...e]}command;chain(...e){return this.command.push(...e),this}get(...e){return this.chain("get",...e)}set(...e){return this.chain("set",...e)}incrby(...e){return this.chain("incrby",...e)}overflow(e){return this.chain("overflow",e)}exec(){let e=new y(this.command,this.opts);return this.execOperation(e)}},E=class extends y{constructor(e,t){super(["bitop",...e],t)}},v=class extends y{constructor(e,t){super(["bitpos",...e],t)}},S=class extends y{constructor([e,t],s){super(["CLIENT","SETINFO",e.toUpperCase(),t],s)}},A=class extends y{constructor([e,t,s],i){super(["COPY",e,t,...s?.replace?["REPLACE"]:[]],{...i,deserialize:e=>e>0?"COPIED":"NOT_COPIED"})}},R=class extends y{constructor(e){super(["dbsize"],e)}},T=class extends y{constructor(e,t){super(["decr",...e],t)}},L=class extends y{constructor(e,t){super(["decrby",...e],t)}},I=class extends y{constructor(e,t){super(["del",...e],t)}},P=class extends y{constructor(e,t){super(["echo",...e],t)}},N=class extends y{constructor([e,t,s],i){super(["eval_ro",e,t.length,...t,...s??[]],i)}},C=class extends y{constructor([e,t,s],i){super(["eval",e,t.length,...t,...s??[]],i)}},z=class extends y{constructor([e,t,s],i){super(["evalsha_ro",e,t.length,...t,...s??[]],i)}},D=class extends y{constructor([e,t,s],i){super(["evalsha",e,t.length,...t,...s??[]],i)}},M=class extends y{constructor(e,t){super(e.map(e=>"string"==typeof e?e:String(e)),t)}},U=class extends y{constructor(e,t){super(["exists",...e],t)}},W=class extends y{constructor(e,t){super(["expire",...e.filter(Boolean)],t)}},K=class extends y{constructor(e,t){super(["expireat",...e],t)}},B=class extends y{constructor([e,t,s],i){super(["fcall",e,...t?[t.length,...t]:[0],...s??[]],i)}},j=class extends y{constructor([e,t,s],i){super(["fcall_ro",e,...t?[t.length,...t]:[0],...s??[]],i)}},_=class extends y{constructor(e,t){let s=["flushall"];e&&e.length>0&&e[0].async&&s.push("async"),super(s,t)}},G=class extends y{constructor([e],t){let s=["flushdb"];e?.async&&s.push("async"),super(s,t)}},q=class extends y{constructor([e],t){super(["function","delete",e],t)}},Y=class extends y{constructor(e){super(["function","flush"],e)}},F=class extends y{constructor([e],t){let s=["function","list"];e?.libraryName&&s.push("libraryname",e.libraryName),e?.withCode&&s.push("withcode"),super(s,{deserialize:V,...t})}};function V(e){return Array.isArray(e)?e.map(e=>{let t=u(e),s=t.functions.map(e=>u(e));return{libraryName:t.library_name,engine:t.engine,functions:s.map(e=>({name:e.name,description:e.description??void 0,flags:e.flags})),libraryCode:t.library_code}}):[]}var $=class extends y{constructor([e],t){super(["function","load",...e.replace?["replace"]:[],e.code],t)}},J=class extends y{constructor(e){super(["function","stats"],{deserialize:X,...e})}};function X(e){return{engines:Object.fromEntries(Object.entries(Object.fromEntries(Object.entries(u(u(e).engines)).map(([e,t])=>[e,u(t)]))).map(([e,t])=>[e,{librariesCount:t.libraries_count,functionsCount:t.functions_count}]))}}var H=class extends y{constructor([e,t,...s],i){let n=["geoadd",e];"nx"in t&&t.nx?n.push("nx"):"xx"in t&&t.xx&&n.push("xx"),"ch"in t&&t.ch&&n.push("ch"),"latitude"in t&&t.latitude&&n.push(t.longitude,t.latitude,t.member),n.push(...s.flatMap(({latitude:e,longitude:t,member:s})=>[t,e,s])),super(n,i)}},Z=class extends y{constructor([e,t,s,i="M"],n){super(["GEODIST",e,t,s,i],n)}},Q=class extends y{constructor(e,t){let[s]=e;super(["GEOHASH",s,...Array.isArray(e[1])?e[1]:e.slice(1)],t)}},ee=class extends y{constructor(e,t){let[s]=e;super(["GEOPOS",s,...Array.isArray(e[1])?e[1]:e.slice(1)],{deserialize:e=>(function(e){let t=[];for(let s of e)s?.[0]&&s?.[1]&&t.push({lng:Number.parseFloat(s[0]),lat:Number.parseFloat(s[1])});return t})(e),...t})}},et=class extends y{constructor([e,t,s,i,n],r){let c=["GEOSEARCH",e];("FROMMEMBER"===t.type||"frommember"===t.type)&&c.push(t.type,t.member),("FROMLONLAT"===t.type||"fromlonlat"===t.type)&&c.push(t.type,t.coordinate.lon,t.coordinate.lat),("BYRADIUS"===s.type||"byradius"===s.type)&&c.push(s.type,s.radius,s.radiusType),("BYBOX"===s.type||"bybox"===s.type)&&c.push(s.type,s.rect.width,s.rect.height,s.rectType),c.push(i),n?.count&&c.push("COUNT",n.count.limit,...n.count.any?["ANY"]:[]),super([...c,...n?.withCoord?["WITHCOORD"]:[],...n?.withDist?["WITHDIST"]:[],...n?.withHash?["WITHHASH"]:[]],{deserialize:e=>n?.withCoord||n?.withDist||n?.withHash?e.map(e=>{let t=1,s={};try{s.member=JSON.parse(e[0])}catch{s.member=e[0]}return n.withDist&&(s.dist=Number.parseFloat(e[t++])),n.withHash&&(s.hash=e[t++].toString()),n.withCoord&&(s.coord={long:Number.parseFloat(e[t][0]),lat:Number.parseFloat(e[t][1])}),s}):e.map(e=>{try{return{member:JSON.parse(e)}}catch{return{member:e}}}),...r})}},es=class extends y{constructor([e,t,s,i,n,r],c){let o=["GEOSEARCHSTORE",e,t];("FROMMEMBER"===s.type||"frommember"===s.type)&&o.push(s.type,s.member),("FROMLONLAT"===s.type||"fromlonlat"===s.type)&&o.push(s.type,s.coordinate.lon,s.coordinate.lat),("BYRADIUS"===i.type||"byradius"===i.type)&&o.push(i.type,i.radius,i.radiusType),("BYBOX"===i.type||"bybox"===i.type)&&o.push(i.type,i.rect.width,i.rect.height,i.rectType),o.push(n),r?.count&&o.push("COUNT",r.count.limit,...r.count.any?["ANY"]:[]),super([...o,...r?.storeDist?["STOREDIST"]:[]],c)}},ei=class extends y{constructor(e,t){super(["get",...e],t)}},en=class extends y{constructor(e,t){super(["getbit",...e],t)}},er=class extends y{constructor(e,t){super(["getdel",...e],t)}},ec=class extends y{constructor([e,t],s){let i=["getex",e];t&&("ex"in t&&"number"==typeof t.ex?i.push("ex",t.ex):"px"in t&&"number"==typeof t.px?i.push("px",t.px):"exat"in t&&"number"==typeof t.exat?i.push("exat",t.exat):"pxat"in t&&"number"==typeof t.pxat?i.push("pxat",t.pxat):"persist"in t&&t.persist&&i.push("persist")),super(i,s)}},eo=class extends y{constructor(e,t){super(["getrange",...e],t)}},ea=class extends y{constructor(e,t){super(["getset",...e],t)}},el=class extends y{constructor(e,t){super(["hdel",...e],t)}},eh=class extends y{constructor(e,t){super(["hexists",...e],t)}},ep=class extends y{constructor(e,t){let[s,i,n,r]=e,c=Array.isArray(i)?i:[i];super(["hexpire",s,n,...r?[r]:[],"FIELDS",c.length,...c],t)}},eu=class extends y{constructor(e,t){let[s,i,n,r]=e,c=Array.isArray(i)?i:[i];super(["hexpireat",s,n,...r?[r]:[],"FIELDS",c.length,...c],t)}},ed=class extends y{constructor(e,t){let[s,i]=e,n=Array.isArray(i)?i:[i];super(["hexpiretime",s,"FIELDS",n.length,...n],t)}},em=class extends y{constructor(e,t){let[s,i]=e,n=Array.isArray(i)?i:[i];super(["hpersist",s,"FIELDS",n.length,...n],t)}},ew=class extends y{constructor(e,t){let[s,i,n,r]=e,c=Array.isArray(i)?i:[i];super(["hpexpire",s,n,...r?[r]:[],"FIELDS",c.length,...c],t)}},ex=class extends y{constructor(e,t){let[s,i,n,r]=e,c=Array.isArray(i)?i:[i];super(["hpexpireat",s,n,...r?[r]:[],"FIELDS",c.length,...c],t)}},ef=class extends y{constructor(e,t){let[s,i]=e,n=Array.isArray(i)?i:[i];super(["hpexpiretime",s,"FIELDS",n.length,...n],t)}},ey=class extends y{constructor(e,t){let[s,i]=e,n=Array.isArray(i)?i:[i];super(["hpttl",s,"FIELDS",n.length,...n],t)}},eg=class extends y{constructor(e,t){super(["hget",...e],t)}},eb=class extends y{constructor(e,t){super(["hgetall",...e],{deserialize:e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let i=e[s],n=e[s+1];try{let e=!Number.isNaN(Number(n))&&!Number.isSafeInteger(Number(n));t[i]=e?n:JSON.parse(n)}catch{t[i]=n}}return t})(e),...t})}};function eO(e,t){if(t.every(e=>null===e))return null;let s={};for(let[i,n]of e.entries())try{s[n]=JSON.parse(t[i])}catch{s[n]=t[i]}return s}var ek=class extends y{constructor([e,...t],s){super(["hmget",e,...t],{deserialize:e=>eO(t,e),...s})}},eE=class extends y{constructor([e,...t],s){super(["hgetdel",e,"FIELDS",t.length,...t],{deserialize:e=>eO(t.map(String),e),...s})}},ev=class extends y{constructor([e,t,...s],i){let n=["hgetex",e];"ex"in t&&"number"==typeof t.ex?n.push("EX",t.ex):"px"in t&&"number"==typeof t.px?n.push("PX",t.px):"exat"in t&&"number"==typeof t.exat?n.push("EXAT",t.exat):"pxat"in t&&"number"==typeof t.pxat?n.push("PXAT",t.pxat):"persist"in t&&t.persist&&n.push("PERSIST"),n.push("FIELDS",s.length,...s),super(n,{deserialize:e=>eO(s.map(String),e),...i})}},eS=class extends y{constructor(e,t){super(["hincrby",...e],t)}},eA=class extends y{constructor(e,t){super(["hincrbyfloat",...e],t)}},eR=class extends y{constructor([e],t){super(["hkeys",e],t)}},eT=class extends y{constructor(e,t){super(["hlen",...e],t)}},eL=class extends y{constructor([e,t],s){super(["hmset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},eI=class extends y{constructor([e,t,s],i){let n=["hscan",e,t];s?.match&&n.push("match",s.match),"number"==typeof s?.count&&n.push("count",s.count),super(n,{deserialize:h,...i})}},eP=class extends y{constructor([e,t],s){super(["hset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},eN=class extends y{constructor([e,t,s],i){let n=["hsetex",e];t.conditional&&n.push(t.conditional.toUpperCase()),t.expiration&&("ex"in t.expiration&&"number"==typeof t.expiration.ex?n.push("EX",t.expiration.ex):"px"in t.expiration&&"number"==typeof t.expiration.px?n.push("PX",t.expiration.px):"exat"in t.expiration&&"number"==typeof t.expiration.exat?n.push("EXAT",t.expiration.exat):"pxat"in t.expiration&&"number"==typeof t.expiration.pxat?n.push("PXAT",t.expiration.pxat):"keepttl"in t.expiration&&t.expiration.keepttl&&n.push("KEEPTTL"));let r=Object.entries(s);for(let[e,t]of(n.push("FIELDS",r.length),r))n.push(e,t);super(n,i)}},eC=class extends y{constructor(e,t){super(["hsetnx",...e],t)}},ez=class extends y{constructor(e,t){super(["hstrlen",...e],t)}},eD=class extends y{constructor(e,t){let[s,i]=e,n=Array.isArray(i)?i:[i];super(["httl",s,"FIELDS",n.length,...n],t)}},eM=class extends y{constructor(e,t){super(["hvals",...e],t)}},eU=class extends y{constructor(e,t){super(["incr",...e],t)}},eW=class extends y{constructor(e,t){super(["incrby",...e],t)}},eK=class extends y{constructor(e,t){super(["incrbyfloat",...e],t)}},eB=class extends y{constructor(e,t){super(["JSON.ARRAPPEND",...e],t)}},ej=class extends y{constructor(e,t){super(["JSON.ARRINDEX",...e],t)}},e_=class extends y{constructor(e,t){super(["JSON.ARRINSERT",...e],t)}},eG=class extends y{constructor(e,t){super(["JSON.ARRLEN",e[0],e[1]??"$"],t)}},eq=class extends y{constructor(e,t){super(["JSON.ARRPOP",...e],t)}},eY=class extends y{constructor(e,t){super(["JSON.ARRTRIM",e[0],e[1]??"$",e[2]??0,e[3]??0],t)}},eF=class extends y{constructor(e,t){super(["JSON.CLEAR",...e],t)}},eV=class extends y{constructor(e,t){super(["JSON.DEL",...e],t)}},e$=class extends y{constructor(e,t){super(["JSON.FORGET",...e],t)}},eJ=class extends y{constructor(e,t){let s=["JSON.GET"];"string"==typeof e[1]?s.push(...e):(s.push(e[0]),e[1]&&(e[1].indent&&s.push("INDENT",e[1].indent),e[1].newline&&s.push("NEWLINE",e[1].newline),e[1].space&&s.push("SPACE",e[1].space)),s.push(...e.slice(2))),super(s,t)}},eX=class extends y{constructor(e,t){super(["JSON.MERGE",...e],t)}},eH=class extends y{constructor(e,t){super(["JSON.MGET",...e[0],e[1]],t)}},eZ=class extends y{constructor(e,t){let s=["JSON.MSET"];for(let t of e)s.push(t.key,t.path,t.value);super(s,t)}},eQ=class extends y{constructor(e,t){super(["JSON.NUMINCRBY",...e],t)}},e1=class extends y{constructor(e,t){super(["JSON.NUMMULTBY",...e],t)}},e0=class extends y{constructor(e,t){super(["JSON.OBJKEYS",...e],t)}},e2=class extends y{constructor(e,t){super(["JSON.OBJLEN",...e],t)}},e5=class extends y{constructor(e,t){super(["JSON.RESP",...e],t)}},e3=class extends y{constructor(e,t){let s=["JSON.SET",e[0],e[1],e[2]];e[3]&&(e[3].nx?s.push("NX"):e[3].xx&&s.push("XX")),super(s,t)}},e6=class extends y{constructor(e,t){super(["JSON.STRAPPEND",...e],t)}},e8=class extends y{constructor(e,t){super(["JSON.STRLEN",...e],t)}},e4=class extends y{constructor(e,t){super(["JSON.TOGGLE",...e],t)}},e9=class extends y{constructor(e,t){super(["JSON.TYPE",...e],t)}},e7=class extends y{constructor(e,t){super(["keys",...e],t)}},te=class extends y{constructor(e,t){super(["lindex",...e],t)}},tt=class extends y{constructor(e,t){super(["linsert",...e],t)}},ts=class extends y{constructor(e,t){super(["llen",...e],t)}},ti=class extends y{constructor(e,t){super(["lmove",...e],t)}},tn=class extends y{constructor(e,t){let[s,i,n,r]=e;super(["LMPOP",s,...i,n,...r?["COUNT",r]:[]],t)}},tr=class extends y{constructor(e,t){super(["lpop",...e],t)}},tc=class extends y{constructor(e,t){let s=["lpos",e[0],e[1]];"number"==typeof e[2]?.rank&&s.push("rank",e[2].rank),"number"==typeof e[2]?.count&&s.push("count",e[2].count),"number"==typeof e[2]?.maxLen&&s.push("maxLen",e[2].maxLen),super(s,t)}},to=class extends y{constructor(e,t){super(["lpush",...e],t)}},ta=class extends y{constructor(e,t){super(["lpushx",...e],t)}},tl=class extends y{constructor(e,t){super(["lrange",...e],t)}},th=class extends y{constructor(e,t){super(["lrem",...e],t)}},tp=class extends y{constructor(e,t){super(["lset",...e],t)}},tu=class extends y{constructor(e,t){super(["ltrim",...e],t)}},td=class extends y{constructor(e,t){super(["mget",...Array.isArray(e[0])?e[0]:e],t)}},tm=class extends y{constructor([e],t){super(["mset",...Object.entries(e).flatMap(([e,t])=>[e,t])],t)}},tw=class extends y{constructor([e],t){super(["msetnx",...Object.entries(e).flat()],t)}},tx=class extends y{constructor(e,t){super(["persist",...e],t)}},tf=class extends y{constructor(e,t){super(["pexpire",...e],t)}},ty=class extends y{constructor(e,t){super(["pexpireat",...e],t)}},tg=class extends y{constructor(e,t){super(["pfadd",...e],t)}},tb=class extends y{constructor(e,t){super(["pfcount",...e],t)}},tO=class extends y{constructor(e,t){super(["pfmerge",...e],t)}},tk=class extends y{constructor(e,t){let s=["ping"];e?.[0]!==void 0&&s.push(e[0]),super(s,t)}},tE=class extends y{constructor(e,t){super(["psetex",...e],t)}},tv=class extends y{constructor(e,t){super(["pttl",...e],t)}},tS=class extends y{constructor(e,t){super(["publish",...e],t)}},tA=class extends y{constructor(e){super(["randomkey"],e)}},tR=class extends y{constructor(e,t){super(["rename",...e],t)}},tT=class extends y{constructor(e,t){super(["renamenx",...e],t)}},tL=class extends y{constructor(e,t){super(["rpop",...e],t)}},tI=class extends y{constructor(e,t){super(["rpush",...e],t)}},tP=class extends y{constructor(e,t){super(["rpushx",...e],t)}},tN=class extends y{constructor(e,t){super(["sadd",...e],t)}},tC=class extends y{constructor([e,t],s){let i=["scan",e];t?.match&&i.push("match",t.match),"number"==typeof t?.count&&i.push("count",t.count),t&&"withType"in t&&!0===t.withType?i.push("withtype"):t&&"type"in t&&t.type&&t.type.length>0&&i.push("type",t.type),super(i,{deserialize:t?.withType?p:h,...s})}},tz=class extends y{constructor(e,t){super(["scard",...e],t)}},tD=class extends y{constructor(e,t){super(["script","exists",...e],{deserialize:e=>e,...t})}},tM=class extends y{constructor([e],t){let s=["script","flush"];e?.sync?s.push("sync"):e?.async&&s.push("async"),super(s,t)}},tU=class extends y{constructor(e,t){super(["script","load",...e],t)}},tW=class extends y{constructor(e,t){super(["sdiff",...e],t)}},tK=class extends y{constructor(e,t){super(["sdiffstore",...e],t)}},tB=class extends y{constructor([e,t,s],i){let n=["set",e,t];s&&("nx"in s&&s.nx?n.push("nx"):"xx"in s&&s.xx&&n.push("xx"),"get"in s&&s.get&&n.push("get"),"ex"in s&&"number"==typeof s.ex?n.push("ex",s.ex):"px"in s&&"number"==typeof s.px?n.push("px",s.px):"exat"in s&&"number"==typeof s.exat?n.push("exat",s.exat):"pxat"in s&&"number"==typeof s.pxat?n.push("pxat",s.pxat):"keepTtl"in s&&s.keepTtl&&n.push("keepTtl")),super(n,i)}},tj=class extends y{constructor(e,t){super(["setbit",...e],t)}},t_=class extends y{constructor(e,t){super(["setex",...e],t)}},tG=class extends y{constructor(e,t){super(["setnx",...e],t)}},tq=class extends y{constructor(e,t){super(["setrange",...e],t)}},tY=class extends y{constructor(e,t){super(["sinter",...e],t)}},tF=class extends y{constructor(e,t){super(["sinterstore",...e],t)}},tV=class extends y{constructor(e,t){super(["sismember",...e],t)}},t$=class extends y{constructor(e,t){super(["smembers",...e],t)}},tJ=class extends y{constructor(e,t){super(["smismember",e[0],...e[1]],t)}},tX=class extends y{constructor(e,t){super(["smove",...e],t)}},tH=class extends y{constructor([e,t],s){let i=["spop",e];"number"==typeof t&&i.push(t),super(i,s)}},tZ=class extends y{constructor([e,t],s){let i=["srandmember",e];"number"==typeof t&&i.push(t),super(i,s)}},tQ=class extends y{constructor(e,t){super(["srem",...e],t)}},t1=class extends y{constructor([e,t,s],i){let n=["sscan",e,t];s?.match&&n.push("match",s.match),"number"==typeof s?.count&&n.push("count",s.count),super(n,{deserialize:h,...i})}},t0=class extends y{constructor(e,t){super(["strlen",...e],t)}},t2=class extends y{constructor(e,t){super(["sunion",...e],t)}},t5=class extends y{constructor(e,t){super(["sunionstore",...e],t)}},t3=class extends y{constructor(e){super(["time"],e)}},t6=class extends y{constructor(e,t){super(["touch",...e],t)}},t8=class extends y{constructor(e,t){super(["ttl",...e],t)}},t4=class extends y{constructor(e,t){super(["type",...e],t)}},t9=class extends y{constructor(e,t){super(["unlink",...e],t)}},t7=class extends y{constructor([e,t,s],i){super(["XACK",e,t,...Array.isArray(s)?[...s]:[s]],i)}},se=class extends y{constructor([e,t,s,...i],n){let r=["XACKDEL",e,t];r.push(s.toUpperCase()),r.push("IDS",i.length,...i),super(r,n)}},st=class extends y{constructor([e,t,s,i],n){let r=["XADD",e];for(let[e,n]of(i&&(i.nomkStream&&r.push("NOMKSTREAM"),i.trim&&(r.push(i.trim.type,i.trim.comparison,i.trim.threshold),void 0!==i.trim.limit&&r.push("LIMIT",i.trim.limit))),r.push(t),Object.entries(s)))r.push(e,n);super(r,n)}},ss=class extends y{constructor([e,t,s,i,n,r],c){let o=[];r?.count&&o.push("COUNT",r.count),r?.justId&&o.push("JUSTID"),super(["XAUTOCLAIM",e,t,s,i,n,...o],c)}},si=class extends y{constructor([e,t,s,i,n,r],c){let o=Array.isArray(n)?[...n]:[n],a=[];r?.idleMS&&a.push("IDLE",r.idleMS),r?.idleMS&&a.push("TIME",r.timeMS),r?.retryCount&&a.push("RETRYCOUNT",r.retryCount),r?.force&&a.push("FORCE"),r?.justId&&a.push("JUSTID"),r?.lastId&&a.push("LASTID",r.lastId),super(["XCLAIM",e,t,s,i,...o,...a],c)}},sn=class extends y{constructor([e,t],s){super(["XDEL",e,...Array.isArray(t)?[...t]:[t]],s)}},sr=class extends y{constructor([e,t,...s],i){let n=["XDELEX",e];t&&n.push(t.toUpperCase()),n.push("IDS",s.length,...s),super(n,i)}},sc=class extends y{constructor([e,t],s){let i=["XGROUP"];switch(t.type){case"CREATE":i.push("CREATE",e,t.group,t.id),t.options&&(t.options.MKSTREAM&&i.push("MKSTREAM"),void 0!==t.options.ENTRIESREAD&&i.push("ENTRIESREAD",t.options.ENTRIESREAD.toString()));break;case"CREATECONSUMER":i.push("CREATECONSUMER",e,t.group,t.consumer);break;case"DELCONSUMER":i.push("DELCONSUMER",e,t.group,t.consumer);break;case"DESTROY":i.push("DESTROY",e,t.group);break;case"SETID":i.push("SETID",e,t.group,t.id),t.options?.ENTRIESREAD!==void 0&&i.push("ENTRIESREAD",t.options.ENTRIESREAD.toString());break;default:throw Error("Invalid XGROUP")}super(i,s)}},so=class extends y{constructor([e,t],s){let i=[];"CONSUMERS"===t.type?i.push("CONSUMERS",e,t.group):i.push("GROUPS",e),super(["XINFO",...i],s)}},sa=class extends y{constructor(e,t){super(["XLEN",...e],t)}},sl=class extends y{constructor([e,t,s,i,n,r],c){super(["XPENDING",e,t,...r?.idleTime?["IDLE",r.idleTime]:[],s,i,n,...r?.consumer===void 0?[]:Array.isArray(r.consumer)?[...r.consumer]:[r.consumer]],c)}},sh=class extends y{constructor([e,t,s,i],n){let r=["XRANGE",e,t,s];"number"==typeof i&&r.push("COUNT",i),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let i=s[e],n=s[e+1];i in t||(t[i]={});for(let e=0;e<n.length;e+=2){let s=n[e],r=n[e+1];try{t[i][s]=JSON.parse(r)}catch{t[i][s]=r}}}return t})(e),...n})}},sp=class extends y{constructor([e,t,s],i){if(Array.isArray(e)&&Array.isArray(t)&&e.length!==t.length)throw Error("ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified");let n=[];"number"==typeof s?.count&&n.push("COUNT",s.count),"number"==typeof s?.blockMS&&n.push("BLOCK",s.blockMS),n.push("STREAMS",...Array.isArray(e)?[...e]:[e],...Array.isArray(t)?[...t]:[t]),super(["XREAD",...n],i)}},su=class extends y{constructor([e,t,s,i,n],r){if(Array.isArray(s)&&Array.isArray(i)&&s.length!==i.length)throw Error("ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified");let c=[];"number"==typeof n?.count&&c.push("COUNT",n.count),"number"==typeof n?.blockMS&&c.push("BLOCK",n.blockMS),"boolean"==typeof n?.NOACK&&n.NOACK&&c.push("NOACK"),c.push("STREAMS",...Array.isArray(s)?[...s]:[s],...Array.isArray(i)?[...i]:[i]),super(["XREADGROUP","GROUP",e,t,...c],r)}},sd=class extends y{constructor([e,t,s,i],n){let r=["XREVRANGE",e,t,s];"number"==typeof i&&r.push("COUNT",i),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let i=s[e],n=s[e+1];i in t||(t[i]={});for(let e=0;e<n.length;e+=2){let s=n[e],r=n[e+1];try{t[i][s]=JSON.parse(r)}catch{t[i][s]=r}}}return t})(e),...n})}},sm=class extends y{constructor([e,t],s){let{limit:i,strategy:n,threshold:r,exactness:c="~"}=t;super(["XTRIM",e,n,c,r,...i?["LIMIT",i]:[]],s)}},sw=class extends y{constructor([e,t,...s],i){let n=["zadd",e];"nx"in t&&t.nx?n.push("nx"):"xx"in t&&t.xx&&n.push("xx"),"ch"in t&&t.ch&&n.push("ch"),"incr"in t&&t.incr&&n.push("incr"),"lt"in t&&t.lt?n.push("lt"):"gt"in t&&t.gt&&n.push("gt"),"score"in t&&"member"in t&&n.push(t.score,t.member),n.push(...s.flatMap(({score:e,member:t})=>[e,t])),super(n,i)}},sx=class extends y{constructor(e,t){super(["zcard",...e],t)}},sf=class extends y{constructor(e,t){super(["zcount",...e],t)}},sy=class extends y{constructor(e,t){super(["zincrby",...e],t)}},sg=class extends y{constructor([e,t,s,i],n){let r=["zinterstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),i&&("weights"in i&&i.weights?r.push("weights",...i.weights):"weight"in i&&"number"==typeof i.weight&&r.push("weights",i.weight),"aggregate"in i&&r.push("aggregate",i.aggregate)),super(r,n)}},sb=class extends y{constructor(e,t){super(["zlexcount",...e],t)}},sO=class extends y{constructor([e,t],s){let i=["zpopmax",e];"number"==typeof t&&i.push(t),super(i,s)}},sk=class extends y{constructor([e,t],s){let i=["zpopmin",e];"number"==typeof t&&i.push(t),super(i,s)}},sE=class extends y{constructor([e,t,s,i],n){let r=["zrange",e,t,s];i?.byScore&&r.push("byscore"),i?.byLex&&r.push("bylex"),i?.rev&&r.push("rev"),i?.count!==void 0&&void 0!==i.offset&&r.push("limit",i.offset,i.count),i?.withScores&&r.push("withscores"),super(r,n)}},sv=class extends y{constructor(e,t){super(["zrank",...e],t)}},sS=class extends y{constructor(e,t){super(["zrem",...e],t)}},sA=class extends y{constructor(e,t){super(["zremrangebylex",...e],t)}},sR=class extends y{constructor(e,t){super(["zremrangebyrank",...e],t)}},sT=class extends y{constructor(e,t){super(["zremrangebyscore",...e],t)}},sL=class extends y{constructor(e,t){super(["zrevrank",...e],t)}},sI=class extends y{constructor([e,t,s],i){let n=["zscan",e,t];s?.match&&n.push("match",s.match),"number"==typeof s?.count&&n.push("count",s.count),super(n,{deserialize:h,...i})}},sP=class extends y{constructor(e,t){super(["zscore",...e],t)}},sN=class extends y{constructor([e,t,s],i){let n=["zunion",e];Array.isArray(t)?n.push(...t):n.push(t),s&&("weights"in s&&s.weights?n.push("weights",...s.weights):"weight"in s&&"number"==typeof s.weight&&n.push("weights",s.weight),"aggregate"in s&&n.push("aggregate",s.aggregate),s.withScores&&n.push("withscores")),super(n,i)}},sC=class extends y{constructor([e,t,s,i],n){let r=["zunionstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),i&&("weights"in i&&i.weights?r.push("weights",...i.weights):"weight"in i&&"number"==typeof i.weight&&r.push("weights",i.weight),"aggregate"in i&&r.push("aggregate",i.aggregate)),super(r,n)}},sz=class extends y{constructor(e,t){super(["zdiffstore",...e],t)}},sD=class extends y{constructor(e,t){let[s,i]=e;super(["zmscore",s,...i],t)}},sM=class{client;commands;commandOptions;multiExec;constructor(e){if(this.client=e.client,this.commands=[],this.commandOptions=e.commandOptions,this.multiExec=e.multiExec??!1,this.commandOptions?.latencyLogging){let e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),i=await (t?e(t):e()),n=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.multiExec?["MULTI-EXEC"]:["PIPELINE"].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${n} ms\x1b[0m`),i}}}exec=async e=>{if(0===this.commands.length)throw Error("Pipeline is empty");let t=this.multiExec?["multi-exec"]:["pipeline"],s=await this.client.request({path:t,body:Object.values(this.commands).map(e=>e.command)});return e?.keepErrors?s.map(({error:e,result:t},s)=>({error:e,result:this.commands[s].deserialize(t)})):s.map(({error:e,result:t},s)=>{if(e)throw new c(`Command ${s+1} [ ${this.commands[s].command[0]} ] failed: ${e}`);return this.commands[s].deserialize(t)})};length(){return this.commands.length}chain(e){return this.commands.push(e),this}append=(...e)=>this.chain(new b(e,this.commandOptions));bitcount=(...e)=>this.chain(new O(e,this.commandOptions));bitfield=(...e)=>new k(e,this.client,this.commandOptions,this.chain.bind(this));bitop=(e,t,s,...i)=>this.chain(new E([e,t,s,...i],this.commandOptions));bitpos=(...e)=>this.chain(new v(e,this.commandOptions));clientSetinfo=(...e)=>this.chain(new S(e,this.commandOptions));copy=(...e)=>this.chain(new A(e,this.commandOptions));zdiffstore=(...e)=>this.chain(new sz(e,this.commandOptions));dbsize=()=>this.chain(new R(this.commandOptions));decr=(...e)=>this.chain(new T(e,this.commandOptions));decrby=(...e)=>this.chain(new L(e,this.commandOptions));del=(...e)=>this.chain(new I(e,this.commandOptions));echo=(...e)=>this.chain(new P(e,this.commandOptions));evalRo=(...e)=>this.chain(new N(e,this.commandOptions));eval=(...e)=>this.chain(new C(e,this.commandOptions));evalshaRo=(...e)=>this.chain(new z(e,this.commandOptions));evalsha=(...e)=>this.chain(new D(e,this.commandOptions));exists=(...e)=>this.chain(new U(e,this.commandOptions));expire=(...e)=>this.chain(new W(e,this.commandOptions));expireat=(...e)=>this.chain(new K(e,this.commandOptions));flushall=e=>this.chain(new _(e,this.commandOptions));flushdb=(...e)=>this.chain(new G(e,this.commandOptions));geoadd=(...e)=>this.chain(new H(e,this.commandOptions));geodist=(...e)=>this.chain(new Z(e,this.commandOptions));geopos=(...e)=>this.chain(new ee(e,this.commandOptions));geohash=(...e)=>this.chain(new Q(e,this.commandOptions));geosearch=(...e)=>this.chain(new et(e,this.commandOptions));geosearchstore=(...e)=>this.chain(new es(e,this.commandOptions));get=(...e)=>this.chain(new ei(e,this.commandOptions));getbit=(...e)=>this.chain(new en(e,this.commandOptions));getdel=(...e)=>this.chain(new er(e,this.commandOptions));getex=(...e)=>this.chain(new ec(e,this.commandOptions));getrange=(...e)=>this.chain(new eo(e,this.commandOptions));getset=(e,t)=>this.chain(new ea([e,t],this.commandOptions));hdel=(...e)=>this.chain(new el(e,this.commandOptions));hexists=(...e)=>this.chain(new eh(e,this.commandOptions));hexpire=(...e)=>this.chain(new ep(e,this.commandOptions));hexpireat=(...e)=>this.chain(new eu(e,this.commandOptions));hexpiretime=(...e)=>this.chain(new ed(e,this.commandOptions));httl=(...e)=>this.chain(new eD(e,this.commandOptions));hpexpire=(...e)=>this.chain(new ew(e,this.commandOptions));hpexpireat=(...e)=>this.chain(new ex(e,this.commandOptions));hpexpiretime=(...e)=>this.chain(new ef(e,this.commandOptions));hpttl=(...e)=>this.chain(new ey(e,this.commandOptions));hpersist=(...e)=>this.chain(new em(e,this.commandOptions));hget=(...e)=>this.chain(new eg(e,this.commandOptions));hgetall=(...e)=>this.chain(new eb(e,this.commandOptions));hgetdel=(...e)=>this.chain(new eE(e,this.commandOptions));hgetex=(...e)=>this.chain(new ev(e,this.commandOptions));hincrby=(...e)=>this.chain(new eS(e,this.commandOptions));hincrbyfloat=(...e)=>this.chain(new eA(e,this.commandOptions));hkeys=(...e)=>this.chain(new eR(e,this.commandOptions));hlen=(...e)=>this.chain(new eT(e,this.commandOptions));hmget=(...e)=>this.chain(new ek(e,this.commandOptions));hmset=(e,t)=>this.chain(new eL([e,t],this.commandOptions));hrandfield=(e,t,s)=>this.chain(new g([e,t,s],this.commandOptions));hscan=(...e)=>this.chain(new eI(e,this.commandOptions));hset=(e,t)=>this.chain(new eP([e,t],this.commandOptions));hsetex=(...e)=>this.chain(new eN(e,this.commandOptions));hsetnx=(e,t,s)=>this.chain(new eC([e,t,s],this.commandOptions));hstrlen=(...e)=>this.chain(new ez(e,this.commandOptions));hvals=(...e)=>this.chain(new eM(e,this.commandOptions));incr=(...e)=>this.chain(new eU(e,this.commandOptions));incrby=(...e)=>this.chain(new eW(e,this.commandOptions));incrbyfloat=(...e)=>this.chain(new eK(e,this.commandOptions));keys=(...e)=>this.chain(new e7(e,this.commandOptions));lindex=(...e)=>this.chain(new te(e,this.commandOptions));linsert=(e,t,s,i)=>this.chain(new tt([e,t,s,i],this.commandOptions));llen=(...e)=>this.chain(new ts(e,this.commandOptions));lmove=(...e)=>this.chain(new ti(e,this.commandOptions));lpop=(...e)=>this.chain(new tr(e,this.commandOptions));lmpop=(...e)=>this.chain(new tn(e,this.commandOptions));lpos=(...e)=>this.chain(new tc(e,this.commandOptions));lpush=(e,...t)=>this.chain(new to([e,...t],this.commandOptions));lpushx=(e,...t)=>this.chain(new ta([e,...t],this.commandOptions));lrange=(...e)=>this.chain(new tl(e,this.commandOptions));lrem=(e,t,s)=>this.chain(new th([e,t,s],this.commandOptions));lset=(e,t,s)=>this.chain(new tp([e,t,s],this.commandOptions));ltrim=(...e)=>this.chain(new tu(e,this.commandOptions));mget=(...e)=>this.chain(new td(e,this.commandOptions));mset=e=>this.chain(new tm([e],this.commandOptions));msetnx=e=>this.chain(new tw([e],this.commandOptions));persist=(...e)=>this.chain(new tx(e,this.commandOptions));pexpire=(...e)=>this.chain(new tf(e,this.commandOptions));pexpireat=(...e)=>this.chain(new ty(e,this.commandOptions));pfadd=(...e)=>this.chain(new tg(e,this.commandOptions));pfcount=(...e)=>this.chain(new tb(e,this.commandOptions));pfmerge=(...e)=>this.chain(new tO(e,this.commandOptions));ping=e=>this.chain(new tk(e,this.commandOptions));psetex=(e,t,s)=>this.chain(new tE([e,t,s],this.commandOptions));pttl=(...e)=>this.chain(new tv(e,this.commandOptions));publish=(...e)=>this.chain(new tS(e,this.commandOptions));randomkey=()=>this.chain(new tA(this.commandOptions));rename=(...e)=>this.chain(new tR(e,this.commandOptions));renamenx=(...e)=>this.chain(new tT(e,this.commandOptions));rpop=(...e)=>this.chain(new tL(e,this.commandOptions));rpush=(e,...t)=>this.chain(new tI([e,...t],this.commandOptions));rpushx=(e,...t)=>this.chain(new tP([e,...t],this.commandOptions));sadd=(e,t,...s)=>this.chain(new tN([e,t,...s],this.commandOptions));scan=(...e)=>this.chain(new tC(e,this.commandOptions));scard=(...e)=>this.chain(new tz(e,this.commandOptions));scriptExists=(...e)=>this.chain(new tD(e,this.commandOptions));scriptFlush=(...e)=>this.chain(new tM(e,this.commandOptions));scriptLoad=(...e)=>this.chain(new tU(e,this.commandOptions));sdiff=(...e)=>this.chain(new tW(e,this.commandOptions));sdiffstore=(...e)=>this.chain(new tK(e,this.commandOptions));set=(e,t,s)=>this.chain(new tB([e,t,s],this.commandOptions));setbit=(...e)=>this.chain(new tj(e,this.commandOptions));setex=(e,t,s)=>this.chain(new t_([e,t,s],this.commandOptions));setnx=(e,t)=>this.chain(new tG([e,t],this.commandOptions));setrange=(...e)=>this.chain(new tq(e,this.commandOptions));sinter=(...e)=>this.chain(new tY(e,this.commandOptions));sinterstore=(...e)=>this.chain(new tF(e,this.commandOptions));sismember=(e,t)=>this.chain(new tV([e,t],this.commandOptions));smembers=(...e)=>this.chain(new t$(e,this.commandOptions));smismember=(e,t)=>this.chain(new tJ([e,t],this.commandOptions));smove=(e,t,s)=>this.chain(new tX([e,t,s],this.commandOptions));spop=(...e)=>this.chain(new tH(e,this.commandOptions));srandmember=(...e)=>this.chain(new tZ(e,this.commandOptions));srem=(e,...t)=>this.chain(new tQ([e,...t],this.commandOptions));sscan=(...e)=>this.chain(new t1(e,this.commandOptions));strlen=(...e)=>this.chain(new t0(e,this.commandOptions));sunion=(...e)=>this.chain(new t2(e,this.commandOptions));sunionstore=(...e)=>this.chain(new t5(e,this.commandOptions));time=()=>this.chain(new t3(this.commandOptions));touch=(...e)=>this.chain(new t6(e,this.commandOptions));ttl=(...e)=>this.chain(new t8(e,this.commandOptions));type=(...e)=>this.chain(new t4(e,this.commandOptions));unlink=(...e)=>this.chain(new t9(e,this.commandOptions));zadd=(...e)=>(e[1],this.chain(new sw([e[0],e[1],...e.slice(2)],this.commandOptions)));xadd=(...e)=>this.chain(new st(e,this.commandOptions));xack=(...e)=>this.chain(new t7(e,this.commandOptions));xackdel=(...e)=>this.chain(new se(e,this.commandOptions));xdel=(...e)=>this.chain(new sn(e,this.commandOptions));xdelex=(...e)=>this.chain(new sr(e,this.commandOptions));xgroup=(...e)=>this.chain(new sc(e,this.commandOptions));xread=(...e)=>this.chain(new sp(e,this.commandOptions));xreadgroup=(...e)=>this.chain(new su(e,this.commandOptions));xinfo=(...e)=>this.chain(new so(e,this.commandOptions));xlen=(...e)=>this.chain(new sa(e,this.commandOptions));xpending=(...e)=>this.chain(new sl(e,this.commandOptions));xclaim=(...e)=>this.chain(new si(e,this.commandOptions));xautoclaim=(...e)=>this.chain(new ss(e,this.commandOptions));xtrim=(...e)=>this.chain(new sm(e,this.commandOptions));xrange=(...e)=>this.chain(new sh(e,this.commandOptions));xrevrange=(...e)=>this.chain(new sd(e,this.commandOptions));zcard=(...e)=>this.chain(new sx(e,this.commandOptions));zcount=(...e)=>this.chain(new sf(e,this.commandOptions));zincrby=(e,t,s)=>this.chain(new sy([e,t,s],this.commandOptions));zinterstore=(...e)=>this.chain(new sg(e,this.commandOptions));zlexcount=(...e)=>this.chain(new sb(e,this.commandOptions));zmscore=(...e)=>this.chain(new sD(e,this.commandOptions));zpopmax=(...e)=>this.chain(new sO(e,this.commandOptions));zpopmin=(...e)=>this.chain(new sk(e,this.commandOptions));zrange=(...e)=>this.chain(new sE(e,this.commandOptions));zrank=(e,t)=>this.chain(new sv([e,t],this.commandOptions));zrem=(e,...t)=>this.chain(new sS([e,...t],this.commandOptions));zremrangebylex=(...e)=>this.chain(new sA(e,this.commandOptions));zremrangebyrank=(...e)=>this.chain(new sR(e,this.commandOptions));zremrangebyscore=(...e)=>this.chain(new sT(e,this.commandOptions));zrevrank=(e,t)=>this.chain(new sL([e,t],this.commandOptions));zscan=(...e)=>this.chain(new sI(e,this.commandOptions));zscore=(e,t)=>this.chain(new sP([e,t],this.commandOptions));zunionstore=(...e)=>this.chain(new sC(e,this.commandOptions));zunion=(...e)=>this.chain(new sN(e,this.commandOptions));get json(){return{arrappend:(...e)=>this.chain(new eB(e,this.commandOptions)),arrindex:(...e)=>this.chain(new ej(e,this.commandOptions)),arrinsert:(...e)=>this.chain(new e_(e,this.commandOptions)),arrlen:(...e)=>this.chain(new eG(e,this.commandOptions)),arrpop:(...e)=>this.chain(new eq(e,this.commandOptions)),arrtrim:(...e)=>this.chain(new eY(e,this.commandOptions)),clear:(...e)=>this.chain(new eF(e,this.commandOptions)),del:(...e)=>this.chain(new eV(e,this.commandOptions)),forget:(...e)=>this.chain(new e$(e,this.commandOptions)),get:(...e)=>this.chain(new eJ(e,this.commandOptions)),merge:(...e)=>this.chain(new eX(e,this.commandOptions)),mget:(...e)=>this.chain(new eH(e,this.commandOptions)),mset:(...e)=>this.chain(new eZ(e,this.commandOptions)),numincrby:(...e)=>this.chain(new eQ(e,this.commandOptions)),nummultby:(...e)=>this.chain(new e1(e,this.commandOptions)),objkeys:(...e)=>this.chain(new e0(e,this.commandOptions)),objlen:(...e)=>this.chain(new e2(e,this.commandOptions)),resp:(...e)=>this.chain(new e5(e,this.commandOptions)),set:(...e)=>this.chain(new e3(e,this.commandOptions)),strappend:(...e)=>this.chain(new e6(e,this.commandOptions)),strlen:(...e)=>this.chain(new e8(e,this.commandOptions)),toggle:(...e)=>this.chain(new e4(e,this.commandOptions)),type:(...e)=>this.chain(new e9(e,this.commandOptions))}}get functions(){return{load:(...e)=>this.chain(new $(e,this.commandOptions)),list:(...e)=>this.chain(new F(e,this.commandOptions)),delete:(...e)=>this.chain(new q(e,this.commandOptions)),flush:()=>this.chain(new Y(this.commandOptions)),stats:()=>this.chain(new J(this.commandOptions)),call:(...e)=>this.chain(new B(e,this.commandOptions)),callRo:(...e)=>this.chain(new j(e,this.commandOptions))}}},sU=new Set(["scan","keys","flushdb","flushall","dbsize","hscan","hgetall","hkeys","lrange","sscan","smembers","xrange","xrevrange","zscan","zrange","exec"]),sW=class{pipelinePromises=new WeakMap;activePipeline=null;indexInCurrentPipeline=0;redis;pipeline;pipelineCounter=0;constructor(e){this.redis=e,this.pipeline=e.pipeline()}async withAutoPipeline(e){let t=this.activePipeline??this.redis.pipeline();this.activePipeline||(this.activePipeline=t,this.indexInCurrentPipeline=0);let s=this.indexInCurrentPipeline++;e(t);let i=this.deferExecution().then(()=>{if(!this.pipelinePromises.has(t)){let e=t.exec({keepErrors:!0});this.pipelineCounter+=1,this.pipelinePromises.set(t,e),this.activePipeline=null}return this.pipelinePromises.get(t)}),n=(await i)[s];if(n.error)throw new c(`Command failed: ${n.error}`);return n.result}async deferExecution(){await Promise.resolve(),await Promise.resolve()}},sK=class extends y{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["psubscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},sB=class extends EventTarget{subscriptions;client;listeners;opts;constructor(e,t,s=!1,i){for(let n of(super(),this.client=e,this.subscriptions=new Map,this.listeners=new Map,this.opts=i,t))s?this.subscribeToPattern(n):this.subscribeToChannel(n)}subscribeToChannel(e){let t=new AbortController,s=new sj([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!1)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!1})}subscribeToPattern(e){let t=new AbortController,s=new sK([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!0)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!0})}handleMessage(e,t){let s=e.replace(/^data:\s*/,""),i=s.indexOf(","),n=s.indexOf(",",i+1),r=t?s.indexOf(",",n+1):-1;if(-1!==i&&-1!==n){let e=s.slice(0,i);if(t&&"pmessage"===e&&-1!==r){let e=s.slice(i+1,n),t=s.slice(n+1,r),c=s.slice(r+1);try{let s=this.opts?.automaticDeserialization===!1?c:JSON.parse(c);this.dispatchToListeners("pmessage",{pattern:e,channel:t,message:s}),this.dispatchToListeners(`pmessage:${e}`,{pattern:e,channel:t,message:s})}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}else{let t=s.slice(i+1,n),r=s.slice(n+1);try{if("subscribe"===e||"psubscribe"===e||"unsubscribe"===e||"punsubscribe"===e){let t=Number.parseInt(r);this.dispatchToListeners(e,t)}else{let s=this.opts?.automaticDeserialization===!1?r:s_(r);this.dispatchToListeners(e,{channel:t,message:s}),this.dispatchToListeners(`${e}:${t}`,{channel:t,message:s})}}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}}}dispatchToListeners(e,t){let s=this.listeners.get(e);if(s)for(let e of s)e(t)}on(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e)?.add(t)}removeAllListeners(){this.listeners.clear()}async unsubscribe(e){if(e)for(let t of e){let e=this.subscriptions.get(t);if(e){try{e.controller.abort()}catch{}this.subscriptions.delete(t)}}else{for(let e of this.subscriptions.values())try{e.controller.abort()}catch{}this.subscriptions.clear(),this.removeAllListeners()}}getSubscribedChannels(){return[...this.subscriptions.keys()]}},sj=class extends y{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["subscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},s_=e=>{try{return JSON.parse(e)}catch{return e}},sG=class{script;sha1;redis;constructor(e,t){this.redis=e,this.script=t,this.sha1="",this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async eval(e,t){return await this.init(this.script),await this.redis.eval(this.script,e,t)}async evalsha(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.eval(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await n.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},sq=class{script;sha1;redis;constructor(e,t){this.redis=e,this.sha1="",this.script=t,this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async evalRo(e,t){return await this.init(this.script),await this.redis.evalRo(this.script,e,t)}async evalshaRo(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.evalRo(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await n.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},sY=class{client;opts;enableTelemetry;enableAutoPipelining;constructor(e,t){this.client=e,this.opts=t,this.enableTelemetry=t?.enableTelemetry??!0,t?.readYourWrites===!1&&(this.client.readYourWrites=!1),this.enableAutoPipelining=t?.enableAutoPipelining??!0}get readYourWritesSyncToken(){return this.client.upstashSyncToken}set readYourWritesSyncToken(e){this.client.upstashSyncToken=e}get json(){return{arrappend:(...e)=>new eB(e,this.opts).exec(this.client),arrindex:(...e)=>new ej(e,this.opts).exec(this.client),arrinsert:(...e)=>new e_(e,this.opts).exec(this.client),arrlen:(...e)=>new eG(e,this.opts).exec(this.client),arrpop:(...e)=>new eq(e,this.opts).exec(this.client),arrtrim:(...e)=>new eY(e,this.opts).exec(this.client),clear:(...e)=>new eF(e,this.opts).exec(this.client),del:(...e)=>new eV(e,this.opts).exec(this.client),forget:(...e)=>new e$(e,this.opts).exec(this.client),get:(...e)=>new eJ(e,this.opts).exec(this.client),merge:(...e)=>new eX(e,this.opts).exec(this.client),mget:(...e)=>new eH(e,this.opts).exec(this.client),mset:(...e)=>new eZ(e,this.opts).exec(this.client),numincrby:(...e)=>new eQ(e,this.opts).exec(this.client),nummultby:(...e)=>new e1(e,this.opts).exec(this.client),objkeys:(...e)=>new e0(e,this.opts).exec(this.client),objlen:(...e)=>new e2(e,this.opts).exec(this.client),resp:(...e)=>new e5(e,this.opts).exec(this.client),set:(...e)=>new e3(e,this.opts).exec(this.client),strappend:(...e)=>new e6(e,this.opts).exec(this.client),strlen:(...e)=>new e8(e,this.opts).exec(this.client),toggle:(...e)=>new e4(e,this.opts).exec(this.client),type:(...e)=>new e9(e,this.opts).exec(this.client)}}get functions(){return{load:(...e)=>new $(e,this.opts).exec(this.client),list:(...e)=>new F(e,this.opts).exec(this.client),delete:(...e)=>new q(e,this.opts).exec(this.client),flush:()=>new Y(this.opts).exec(this.client),stats:()=>new J(this.opts).exec(this.client),call:(...e)=>new B(e,this.opts).exec(this.client),callRo:(...e)=>new j(e,this.opts).exec(this.client)}}use=e=>{let t=this.client.request.bind(this.client);this.client.request=s=>e(s,t)};addTelemetry=e=>{if(this.enableTelemetry)try{this.client.mergeTelemetry(e)}catch{}};createScript(e,t){return t?.readonly?new sq(this,e):new sG(this,e)}pipeline=()=>new sM({client:this.client,commandOptions:this.opts,multiExec:!1});autoPipeline=()=>(function e(t,s="root"){return t.autoPipelineExecutor||(t.autoPipelineExecutor=new sW(t)),new Proxy(t,{get:(t,i)=>{if("pipelineCounter"===i)return t.autoPipelineExecutor.pipelineCounter;if("root"===s&&"json"===i)return e(t,"json");if("root"===s&&"functions"===i)return e(t,"functions");if("root"===s){let e=i in t&&!(i in t.autoPipelineExecutor.pipeline),s=sU.has(i);if(e||s)return t[i]}let n=t.autoPipelineExecutor.pipeline,r="json"===s?n.json[i]:"functions"===s?n.functions[i]:n[i];return"function"==typeof r?(...e)=>t.autoPipelineExecutor.withAutoPipeline(t=>{("json"===s?t.json[i]:"functions"===s?t.functions[i]:t[i])(...e)}):r}})})(this);multi=()=>new sM({client:this.client,commandOptions:this.opts,multiExec:!0});bitfield=(...e)=>new k(e,this.client,this.opts);append=(...e)=>new b(e,this.opts).exec(this.client);bitcount=(...e)=>new O(e,this.opts).exec(this.client);bitop=(e,t,s,...i)=>new E([e,t,s,...i],this.opts).exec(this.client);bitpos=(...e)=>new v(e,this.opts).exec(this.client);clientSetinfo=(...e)=>new S(e,this.opts).exec(this.client);copy=(...e)=>new A(e,this.opts).exec(this.client);dbsize=()=>new R(this.opts).exec(this.client);decr=(...e)=>new T(e,this.opts).exec(this.client);decrby=(...e)=>new L(e,this.opts).exec(this.client);del=(...e)=>new I(e,this.opts).exec(this.client);echo=(...e)=>new P(e,this.opts).exec(this.client);evalRo=(...e)=>new N(e,this.opts).exec(this.client);eval=(...e)=>new C(e,this.opts).exec(this.client);evalshaRo=(...e)=>new z(e,this.opts).exec(this.client);evalsha=(...e)=>new D(e,this.opts).exec(this.client);exec=e=>new M(e,this.opts).exec(this.client);exists=(...e)=>new U(e,this.opts).exec(this.client);expire=(...e)=>new W(e,this.opts).exec(this.client);expireat=(...e)=>new K(e,this.opts).exec(this.client);flushall=e=>new _(e,this.opts).exec(this.client);flushdb=(...e)=>new G(e,this.opts).exec(this.client);geoadd=(...e)=>new H(e,this.opts).exec(this.client);geopos=(...e)=>new ee(e,this.opts).exec(this.client);geodist=(...e)=>new Z(e,this.opts).exec(this.client);geohash=(...e)=>new Q(e,this.opts).exec(this.client);geosearch=(...e)=>new et(e,this.opts).exec(this.client);geosearchstore=(...e)=>new es(e,this.opts).exec(this.client);get=(...e)=>new ei(e,this.opts).exec(this.client);getbit=(...e)=>new en(e,this.opts).exec(this.client);getdel=(...e)=>new er(e,this.opts).exec(this.client);getex=(...e)=>new ec(e,this.opts).exec(this.client);getrange=(...e)=>new eo(e,this.opts).exec(this.client);getset=(e,t)=>new ea([e,t],this.opts).exec(this.client);hdel=(...e)=>new el(e,this.opts).exec(this.client);hexists=(...e)=>new eh(e,this.opts).exec(this.client);hexpire=(...e)=>new ep(e,this.opts).exec(this.client);hexpireat=(...e)=>new eu(e,this.opts).exec(this.client);hexpiretime=(...e)=>new ed(e,this.opts).exec(this.client);httl=(...e)=>new eD(e,this.opts).exec(this.client);hpexpire=(...e)=>new ew(e,this.opts).exec(this.client);hpexpireat=(...e)=>new ex(e,this.opts).exec(this.client);hpexpiretime=(...e)=>new ef(e,this.opts).exec(this.client);hpttl=(...e)=>new ey(e,this.opts).exec(this.client);hpersist=(...e)=>new em(e,this.opts).exec(this.client);hget=(...e)=>new eg(e,this.opts).exec(this.client);hgetall=(...e)=>new eb(e,this.opts).exec(this.client);hgetdel=(...e)=>new eE(e,this.opts).exec(this.client);hgetex=(...e)=>new ev(e,this.opts).exec(this.client);hincrby=(...e)=>new eS(e,this.opts).exec(this.client);hincrbyfloat=(...e)=>new eA(e,this.opts).exec(this.client);hkeys=(...e)=>new eR(e,this.opts).exec(this.client);hlen=(...e)=>new eT(e,this.opts).exec(this.client);hmget=(...e)=>new ek(e,this.opts).exec(this.client);hmset=(e,t)=>new eL([e,t],this.opts).exec(this.client);hrandfield=(e,t,s)=>new g([e,t,s],this.opts).exec(this.client);hscan=(...e)=>new eI(e,this.opts).exec(this.client);hset=(e,t)=>new eP([e,t],this.opts).exec(this.client);hsetex=(...e)=>new eN(e,this.opts).exec(this.client);hsetnx=(e,t,s)=>new eC([e,t,s],this.opts).exec(this.client);hstrlen=(...e)=>new ez(e,this.opts).exec(this.client);hvals=(...e)=>new eM(e,this.opts).exec(this.client);incr=(...e)=>new eU(e,this.opts).exec(this.client);incrby=(...e)=>new eW(e,this.opts).exec(this.client);incrbyfloat=(...e)=>new eK(e,this.opts).exec(this.client);keys=(...e)=>new e7(e,this.opts).exec(this.client);lindex=(...e)=>new te(e,this.opts).exec(this.client);linsert=(e,t,s,i)=>new tt([e,t,s,i],this.opts).exec(this.client);llen=(...e)=>new ts(e,this.opts).exec(this.client);lmove=(...e)=>new ti(e,this.opts).exec(this.client);lpop=(...e)=>new tr(e,this.opts).exec(this.client);lmpop=(...e)=>new tn(e,this.opts).exec(this.client);lpos=(...e)=>new tc(e,this.opts).exec(this.client);lpush=(e,...t)=>new to([e,...t],this.opts).exec(this.client);lpushx=(e,...t)=>new ta([e,...t],this.opts).exec(this.client);lrange=(...e)=>new tl(e,this.opts).exec(this.client);lrem=(e,t,s)=>new th([e,t,s],this.opts).exec(this.client);lset=(e,t,s)=>new tp([e,t,s],this.opts).exec(this.client);ltrim=(...e)=>new tu(e,this.opts).exec(this.client);mget=(...e)=>new td(e,this.opts).exec(this.client);mset=e=>new tm([e],this.opts).exec(this.client);msetnx=e=>new tw([e],this.opts).exec(this.client);persist=(...e)=>new tx(e,this.opts).exec(this.client);pexpire=(...e)=>new tf(e,this.opts).exec(this.client);pexpireat=(...e)=>new ty(e,this.opts).exec(this.client);pfadd=(...e)=>new tg(e,this.opts).exec(this.client);pfcount=(...e)=>new tb(e,this.opts).exec(this.client);pfmerge=(...e)=>new tO(e,this.opts).exec(this.client);ping=e=>new tk(e,this.opts).exec(this.client);psetex=(e,t,s)=>new tE([e,t,s],this.opts).exec(this.client);psubscribe=e=>{let t=Array.isArray(e)?e:[e];return new sB(this.client,t,!0,this.opts)};pttl=(...e)=>new tv(e,this.opts).exec(this.client);publish=(...e)=>new tS(e,this.opts).exec(this.client);randomkey=()=>new tA().exec(this.client);rename=(...e)=>new tR(e,this.opts).exec(this.client);renamenx=(...e)=>new tT(e,this.opts).exec(this.client);rpop=(...e)=>new tL(e,this.opts).exec(this.client);rpush=(e,...t)=>new tI([e,...t],this.opts).exec(this.client);rpushx=(e,...t)=>new tP([e,...t],this.opts).exec(this.client);sadd=(e,t,...s)=>new tN([e,t,...s],this.opts).exec(this.client);scan(e,t){return new tC([e,t],this.opts).exec(this.client)}scard=(...e)=>new tz(e,this.opts).exec(this.client);scriptExists=(...e)=>new tD(e,this.opts).exec(this.client);scriptFlush=(...e)=>new tM(e,this.opts).exec(this.client);scriptLoad=(...e)=>new tU(e,this.opts).exec(this.client);sdiff=(...e)=>new tW(e,this.opts).exec(this.client);sdiffstore=(...e)=>new tK(e,this.opts).exec(this.client);set=(e,t,s)=>new tB([e,t,s],this.opts).exec(this.client);setbit=(...e)=>new tj(e,this.opts).exec(this.client);setex=(e,t,s)=>new t_([e,t,s],this.opts).exec(this.client);setnx=(e,t)=>new tG([e,t],this.opts).exec(this.client);setrange=(...e)=>new tq(e,this.opts).exec(this.client);sinter=(...e)=>new tY(e,this.opts).exec(this.client);sinterstore=(...e)=>new tF(e,this.opts).exec(this.client);sismember=(e,t)=>new tV([e,t],this.opts).exec(this.client);smismember=(e,t)=>new tJ([e,t],this.opts).exec(this.client);smembers=(...e)=>new t$(e,this.opts).exec(this.client);smove=(e,t,s)=>new tX([e,t,s],this.opts).exec(this.client);spop=(...e)=>new tH(e,this.opts).exec(this.client);srandmember=(...e)=>new tZ(e,this.opts).exec(this.client);srem=(e,...t)=>new tQ([e,...t],this.opts).exec(this.client);sscan=(...e)=>new t1(e,this.opts).exec(this.client);strlen=(...e)=>new t0(e,this.opts).exec(this.client);subscribe=e=>{let t=Array.isArray(e)?e:[e];return new sB(this.client,t,!1,this.opts)};sunion=(...e)=>new t2(e,this.opts).exec(this.client);sunionstore=(...e)=>new t5(e,this.opts).exec(this.client);time=()=>new t3().exec(this.client);touch=(...e)=>new t6(e,this.opts).exec(this.client);ttl=(...e)=>new t8(e,this.opts).exec(this.client);type=(...e)=>new t4(e,this.opts).exec(this.client);unlink=(...e)=>new t9(e,this.opts).exec(this.client);xadd=(...e)=>new st(e,this.opts).exec(this.client);xack=(...e)=>new t7(e,this.opts).exec(this.client);xackdel=(...e)=>new se(e,this.opts).exec(this.client);xdel=(...e)=>new sn(e,this.opts).exec(this.client);xdelex=(...e)=>new sr(e,this.opts).exec(this.client);xgroup=(...e)=>new sc(e,this.opts).exec(this.client);xread=(...e)=>new sp(e,this.opts).exec(this.client);xreadgroup=(...e)=>new su(e,this.opts).exec(this.client);xinfo=(...e)=>new so(e,this.opts).exec(this.client);xlen=(...e)=>new sa(e,this.opts).exec(this.client);xpending=(...e)=>new sl(e,this.opts).exec(this.client);xclaim=(...e)=>new si(e,this.opts).exec(this.client);xautoclaim=(...e)=>new ss(e,this.opts).exec(this.client);xtrim=(...e)=>new sm(e,this.opts).exec(this.client);xrange=(...e)=>new sh(e,this.opts).exec(this.client);xrevrange=(...e)=>new sd(e,this.opts).exec(this.client);zadd=(...e)=>(e[1],new sw([e[0],e[1],...e.slice(2)],this.opts).exec(this.client));zcard=(...e)=>new sx(e,this.opts).exec(this.client);zcount=(...e)=>new sf(e,this.opts).exec(this.client);zdiffstore=(...e)=>new sz(e,this.opts).exec(this.client);zincrby=(e,t,s)=>new sy([e,t,s],this.opts).exec(this.client);zinterstore=(...e)=>new sg(e,this.opts).exec(this.client);zlexcount=(...e)=>new sb(e,this.opts).exec(this.client);zmscore=(...e)=>new sD(e,this.opts).exec(this.client);zpopmax=(...e)=>new sO(e,this.opts).exec(this.client);zpopmin=(...e)=>new sk(e,this.opts).exec(this.client);zrange=(...e)=>new sE(e,this.opts).exec(this.client);zrank=(e,t)=>new sv([e,t],this.opts).exec(this.client);zrem=(e,...t)=>new sS([e,...t],this.opts).exec(this.client);zremrangebylex=(...e)=>new sA(e,this.opts).exec(this.client);zremrangebyrank=(...e)=>new sR(e,this.opts).exec(this.client);zremrangebyscore=(...e)=>new sT(e,this.opts).exec(this.client);zrevrank=(e,t)=>new sL([e,t],this.opts).exec(this.client);zscan=(...e)=>new sI(e,this.opts).exec(this.client);zscore=(e,t)=>new sP([e,t],this.opts).exec(this.client);zunion=(...e)=>new sN(e,this.opts).exec(this.client);zunionstore=(...e)=>new sC(e,this.opts).exec(this.client)};"undefined"==typeof atob&&(global.atob=e=>Buffer.from(e,"base64").toString("utf8"));var sF=class e extends sY{constructor(e){if("request"in e){super(e);return}e.url?(e.url.startsWith(" ")||e.url.endsWith(" ")||/\r|\n/.test(e.url))&&console.warn("[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'url' property is missing or undefined in your Redis config."),e.token?(e.token.startsWith(" ")||e.token.endsWith(" ")||/\r|\n/.test(e.token))&&console.warn("[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'token' property is missing or undefined in your Redis config.");let t=new d({baseUrl:e.url,retry:e.retry,headers:{authorization:`Bearer ${e.token}`},agent:e.agent,responseEncoding:e.responseEncoding,cache:e.cache??"no-store",signal:e.signal,keepAlive:e.keepAlive,readYourWrites:e.readYourWrites}),s="object"==typeof process&&process&&"object"==typeof process.env&&process.env?process.env:{};super(t,{automaticDeserialization:e.automaticDeserialization,enableTelemetry:e.enableTelemetry??!s.UPSTASH_DISABLE_TELEMETRY,latencyLogging:e.latencyLogging,enableAutoPipelining:e.enableAutoPipelining});let i="object"==typeof process&&process?process.version:void 0;if(this.addTelemetry({runtime:"string"==typeof EdgeRuntime?"edge-light":i?`node@${i}`:"unknown",platform:s.UPSTASH_CONSOLE?"console":s.VERCEL?"vercel":s.AWS_REGION?"aws":"unknown",sdk:"@upstash/redis@v1.36.2"}),this.enableAutoPipelining)return this.autoPipeline()}static fromEnv(t){if("object"!=typeof process||!process||"object"!=typeof process.env||!process.env)throw TypeError('[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');let s=process.env.UPSTASH_REDIS_REST_URL||process.env.KV_REST_API_URL;s||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");let i=process.env.UPSTASH_REDIS_REST_TOKEN||process.env.KV_REST_API_TOKEN;return i||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`"),new e({...t,url:s,token:i})}}}};